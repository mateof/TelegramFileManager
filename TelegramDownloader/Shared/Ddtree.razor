@using System.Collections.ObjectModel
@using TelegramDownloader.Data
@using TelegramDownloader.Models

@inject IFileService fs


<div class="mb-3">
    <label class="form-label">Folder</label>
    <CustomDropDownTree
        DbName="@id"
        Placeholder="Select a Folder"
        SelectedValue="@(selectedNode?.FirstOrDefault())"
        SelectedValueChanged="OnFolderSelected"
        LoadChildrenFunc="LoadFolders" />
</div>


@code {
#nullable disable
    [Parameter]
    public string id { get; set; }
    [Parameter]
    public string idTree { get; set; } = "mtree";
    [Parameter]
    public List<string> selectedNode { get; set; }
    [Parameter]
    public EventCallback<List<string>> selectedNodeChanged { get; set; }
    [Parameter]
    public string folderType { get; set; } = "local";

    private List<string> localFolderTypes = new List<string> {"local", "temp"};

    private async Task<List<TreeNodeModel>> LoadFolders(string dbName, string parentId)
    {
        if (localFolderTypes.Contains(folderType))
        {
            return await LoadLocalFolders(parentId);
        }
        else
        {
            return await LoadTelegramFolders(dbName, parentId);
        }
    }

    private Task<List<TreeNodeModel>> LoadLocalFolders(string parentPath)
    {
        var result = new List<TreeNodeModel>();
        string basePath = FileService.LOCALDIR;

        // If parentPath is null, load root (temp folder)
        string targetPath = string.IsNullOrEmpty(parentPath) ? basePath : parentPath;

        if (Directory.Exists(targetPath))
        {
            // For root, add the temp folder itself
            if (string.IsNullOrEmpty(parentPath))
            {
                var dirInfo = new DirectoryInfo(targetPath);
                bool hasSubDirs = dirInfo.GetDirectories().Length > 0;
                result.Add(new TreeNodeModel
                {
                    Id = targetPath,
                    OriginalId = targetPath,
                    Name = dirInfo.Name,
                    ParentId = null,
                    HasChildren = hasSubDirs
                });
            }
            else
            {
                // Load subdirectories
                foreach (var dir in Directory.GetDirectories(targetPath))
                {
                    var dirInfo = new DirectoryInfo(dir);
                    bool hasSubDirs = dirInfo.GetDirectories().Length > 0;
                    result.Add(new TreeNodeModel
                    {
                        Id = dir,
                        OriginalId = dir,
                        Name = dirInfo.Name,
                        ParentId = targetPath,
                        HasChildren = hasSubDirs
                    });
                }
            }
        }

        // Sort alphabetically ascending
        return Task.FromResult(result.OrderBy(x => x.Name).ToList());
    }

    private async Task<List<TreeNodeModel>> LoadTelegramFolders(string dbName, string parentId)
    {
        var folders = await fs.getTelegramFoldersByParentId(dbName, parentId);
        var result = new List<TreeNodeModel>();
        foreach (var f in folders)
        {
            // Create a path-based Id for the selected value (like /FolderName/ or /Parent/Child/)
            string pathId;
            if (String.IsNullOrEmpty(f.FilterPath) || f.FilterPath == "/")
            {
                pathId = "/" + f.Name + "/";
            }
            else
            {
                pathId = f.FilterPath + f.Name + "/";
            }

            result.Add(new TreeNodeModel
            {
                Id = pathId,  // Path-based Id for selection
                OriginalId = f.Id,  // MongoDB ObjectId for expansion
                Name = f.Name,
                ParentId = f.ParentId,
                HasChildren = f.HasChild
            });
        }
        // Sort alphabetically ascending
        return result.OrderBy(x => x.Name).ToList();
    }

    private async Task OnFolderSelected(string value)
    {
        selectedNode = new List<string> { value };
        await selectedNodeChanged.InvokeAsync(selectedNode);
    }
}
