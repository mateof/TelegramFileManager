@inherits LayoutComponentBase
@implements IDisposable
@using TelegramDownloader.Data
@using TelegramDownloader.Models
@using TelegramDownloader.Models.GitHub
@using TelegramDownloader.Services
@using TelegramDownloader.Services.GitHub
@using TelegramDownloader.Shared
@inject ISetupService SetupService
@inject ITelegramService ts
@inject NavigationManager NavManager
@inject IJSRuntime JS
@inject ModalService ModalService
@inject TransactionInfoService tis
@inject IFileService FileService

<PageTitle>TelegramFileManager</PageTitle>

<style>
    .modalshow {
        display: block;
    }

    .modalhide {
        display: none;
    }

    /* Sidebar toggle button - styles moved to MainLayout.razor.css */

    /* Sidebar collapsed state - desktop only */
    @@media (min-width: 2048px) {
        .sidebar {
            transition: width 0.3s ease, min-width 0.3s ease;
        }

        .sidebar.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            overflow: hidden !important;
            padding: 0 !important;
        }
    }

    /* Mobile: hide toggle button since NavMenu has its own */
    @@media (max-width: 2048px) {
        .sidebar-toggle {
            display: none;
        }

        /* Sidebar full height when nav menu is expanded */
        .sidebar {
            height: 100vh !important;
            min-height: 100vh !important;
        }

        /* Sidebar collapses when nav menu is collapsed */
        .sidebar.nav-collapsed {
            height: auto !important;
            min-height: auto !important;
            max-height: fit-content !important;
            overflow: hidden !important;
        }
    }
</style>

<link href="css/custombuttons.css" rel="stylesheet" />


<Preload LoadingText="Loading..." />


<div class="page @(sidebarCollapsed ? "sidebar-collapsed" : "")">
    <div class="sidebar @(sidebarCollapsed ? "collapsed" : "") @(navMenuCollapsed ? "nav-collapsed" : "")">
        <NavMenu @ref="menu" OnClickCallback="openOffCanvasMenu" OnClickOpenImportCallback="openImportModalMenu" OnClickCreateChannelCallback="openCreateChannelModal" OnCollapseChanged="OnNavMenuCollapseChanged" />
    </div>

    <main>
        <div class="top-row px-3">
            <button class="sidebar-toggle" @onclick="ToggleSidebar" title="@(sidebarCollapsed ? "Show sidebar" : "Hide sidebar")">
                <i class="bi @(sidebarCollapsed ? "bi-chevron-right" : "bi-chevron-left")"></i>
            </button>

            <div class="flex-grow-1"></div>

            <div class="top-row-actions">
                @if(active) {
                    @if (tis.isSplitting())
                    {
                        <button class="btn status-btn splitting"
                                @onclick='() => Navigateto("/downloads?tab=uploads")' title="Splitting file...">
                            <i class="bi bi-scissors spin"></i>
                            <span>Splitting</span>
                        </button>
                    }
                    else if (tis.isCalculatingHash())
                    {
                        <button class="btn status-btn calculating"
                                @onclick='() => Navigateto("/downloads?tab=uploads")' title="Calculating hash...">
                            <i class="bi bi-calculator"></i>
                            <span>Hashing</span>
                        </button>
                    }
                    else if (tis.isUploading())
                    {
                        <button class="btn water-fill-button upload @(GetUploadProgress() > 50 ? "filled-high" : "")"
                                @onclick='() => Navigateto("/downloads?tab=uploads")' title="Upload in progress">
                            <span class="water-fill" style="height: @(GetUploadProgress())%;"></span>
                            <span class="water-wave" style="height: @(GetUploadProgress())%;"></span>
                            <span class="btn-content">
                                <Icon Class="arrow" Name="IconName.ArrowUp"></Icon>
                                <span>@tis.uploadSpeed</span>
                            </span>
                        </button>
                    }
                    @if(tis.isDownloading()) {
                        <button class="btn water-fill-button download @(GetDownloadProgress() > 50 ? "filled-high" : "")"
                                @onclick='() => Navigateto("/downloads?tab=downloads")' title="Download in progress">
                            <span class="water-fill" style="height: @(GetDownloadProgress())%;"></span>
                            <span class="water-wave" style="height: @(GetDownloadProgress())%;"></span>
                            <span class="btn-content">
                                <Icon Class="arrow" Name="IconName.ArrowDown"></Icon>
                                <span>@tis.downloadSpeed</span>
                            </span>
                        </button>
                    }
                    <button class="status-indicator" @onclick='() => Navigateto("/downloads?tab=tasks")' title="View tasks">
                        <Spinner Type="SpinnerType.Border" />
                    </button>
                }
                <VersionBadge @ref="versionBadge" @bind-ShowModal="showVersionModal" />
                <button class="menu-btn" type="button" @onclick="openOffCanvasMenu" title="Menu">
                    <i class="bi bi-three-dots-vertical"></i>
                </button>
            </div>
        </div>
        <TelegramDownloader.Pages.Modals.ToastNotify></TelegramDownloader.Pages.Modals.ToastNotify>

        <article class="content px-4">
            @Body
        </article>

        <TelegramDownloader.Pages.Modals.AudioPlayerModal @ref="audioPlayer" />
        <TelegramDownloader.Pages.Modals.PlaylistManagerModal @ref="playlistManager"
            OnPlayPlaylist="OnPlayPlaylist"
            OnDownloadPlaylist="OnDownloadPlaylist"
            OnNotify="OnPlaylistNotify" />
        <TelegramDownloader.Pages.Modals.SaveToPlaylistModal @ref="saveToPlaylist"
            OnTrackAdded="OnPlaylistNotify" />

        <Offcanvas @ref="offcanvas" title="Menu">
            <BodyTemplate>
                <div class="offcanvas-section-title">Navigation</div>

                <button @onclick='() => NavigateAndClose("/config")' class="offcanvas-menu-item">
                    <i class="bi bi-gear-fill"></i>
                    <span class="menu-text">Configuration</span>
                </button>

                <button @onclick='() => NavigateAndClose("/webdavinfo")' class="offcanvas-menu-item">
                    <i class="bi bi-hdd-network-fill"></i>
                    <span class="menu-text">WebDav</span>
                    <span class="menu-badge">Beta</span>
                </button>

                <button @onclick='() => NavigateAndClose("/downloads")' class="offcanvas-menu-item">
                    <i class="bi bi-cloud-arrow-down-fill"></i>
                    <span class="menu-text">Tasks</span>
                </button>

                <button @onclick='() => NavigateAndClose("/downloads?tab=persisted")' class="offcanvas-menu-item">
                    <i class="bi bi-database"></i>
                    <span class="menu-text">Saved Tasks</span>
                </button>

                <button @onclick='() => NavigateAndClose("/loglist")' class="offcanvas-menu-item">
                    <i class="bi bi-journal-text"></i>
                    <span class="menu-text">Logs</span>
                </button>

                <div class="offcanvas-divider"></div>
                <div class="offcanvas-section-title">Media</div>

                <button @onclick="OpenPlaylistsAndClose" class="offcanvas-menu-item">
                    <i class="bi bi-music-note-list"></i>
                    <span class="menu-text">Playlists</span>
                </button>

                <div class="offcanvas-divider"></div>
                <div class="offcanvas-section-title">Account</div>

                <button @onclick="LogoutAndClose" class="offcanvas-menu-item danger">
                    <i class="bi bi-box-arrow-right"></i>
                    <span class="menu-text">Log Out</span>
                </button>
            </BodyTemplate>
        </Offcanvas>
        <TelegramDownloader.Pages.Modals.ImportDataModal isShared=true @ref="ImportModal" OnCloseCallback="reloadMenu"></TelegramDownloader.Pages.Modals.ImportDataModal>
        <TelegramDownloader.Pages.Modals.CreateChannelModal @ref="CreateChannelModal" OnChannelCreated="reloadMenu" />

        <Modal IsServiceModal="true" />
        <Toasts class="p-3" AutoHide="true" Delay="4000" Placement="ToastsPlacement.TopRight" />
    </main>
</div>

@* Upload to Telegram Modal - rendered outside .page to avoid stacking context issues *@
<TelegramDownloader.Pages.Modals.UploadToTelegramModal @ref="uploadToTelegramModal" />

@* Delete/Leave Channel Modal - rendered outside .page to avoid stacking context issues *@
<TelegramDownloader.Pages.Modals.DeleteLeaveChannelModal @ref="deleteLeaveChannelModal" OnChannelRemoved="reloadMenu" />

@* Database Maintenance Modal - rendered outside .page to avoid stacking context issues *@
<TelegramDownloader.Pages.Modals.DatabaseMaintenanceModal @ref="databaseMaintenanceModal" />

@* Path Repair Modal - rendered outside .page to avoid stacking context issues *@
<TelegramDownloader.Pages.Modals.PathRepairModal @ref="pathRepairModal" />

@* Vue Upload Modal - rendered outside .page to avoid stacking context issues *@
<div id="modalFileUploadVue">
    <TelegramDownloader.Pages.Modals.FileUploadModalTemplate></TelegramDownloader.Pages.Modals.FileUploadModalTemplate>
</div>

@* Version Modal - rendered outside .page to avoid stacking context issues *@
@if (showVersionModal)
{
    <div class="version-portal">
        <div class="version-backdrop" @onclick="CloseVersionModal"></div>
        <div class="version-dialog">
            <div class="version-dialog-header">
                <h5>Version Information</h5>
                <button type="button" class="btn-close" @onclick="CloseVersionModal"></button>
            </div>
            <div class="version-dialog-body">
                @if (versionBadge?.VersionInfo != null)
                {
                    var info = versionBadge.VersionInfo;
                    <div class="version-current">
                        <div class="version-label">Current Version</div>
                        <div class="version-value">
                            @if (info.IsDockerVersion)
                            {
                                <span class="badge bg-secondary me-2">Docker</span>
                            }
                            else if (info.IsDevVersion)
                            {
                                <span class="badge bg-warning text-dark me-2">Dev</span>
                            }
                            else
                            {
                                <span class="badge bg-success me-2">Release</span>
                            }
                            <code>@info.CurrentVersion</code>
                        </div>
                    </div>

                    @if (info.LatestRelease != null)
                    {
                        <div class="version-section @(info.HasNewRelease ? "has-update" : "")">
                            <div class="version-label">
                                Latest Release
                                @if (info.HasNewRelease)
                                {
                                    <span class="badge bg-primary ms-2">New!</span>
                                }
                            </div>
                            <div class="version-value">
                                <code>@info.LatestRelease.tag_name</code>
                                <small class="text-muted ms-2">@info.LatestRelease.published_at.ToString("yyyy-MM-dd")</small>
                            </div>
                            @if (info.HasNewRelease)
                            {
                                <a href="@info.LatestRelease.html_url" target="_blank" class="btn btn-sm btn-outline-primary mt-2">
                                    <i class="bi bi-box-arrow-up-right"></i> View Release
                                </a>
                            }
                        </div>
                    }

                    @if (info.LatestDev != null)
                    {
                        <div class="version-section @(info.HasNewDev ? "has-update" : "")">
                            <div class="version-label">
                                Latest Dev
                                @if (info.HasNewDev)
                                {
                                    <span class="badge bg-warning text-dark ms-2">New!</span>
                                }
                            </div>
                            <div class="version-value">
                                <code>@info.LatestDev.tag_name</code>
                                <small class="text-muted ms-2">@info.LatestDev.published_at.ToString("yyyy-MM-dd")</small>
                            </div>
                            @if (info.HasNewDev && info.IsDevVersion)
                            {
                                <a href="@info.LatestDev.html_url" target="_blank" class="btn btn-sm btn-outline-warning mt-2">
                                    <i class="bi bi-box-arrow-up-right"></i> View Dev Release
                                </a>
                            }
                        </div>
                    }
                }
                else
                {
                    <div class="text-center py-3">
                        <div class="spinner-border spinner-border-sm" role="status"></div>
                        <span class="ms-2">Loading version info...</span>
                    </div>
                }
            </div>
            <div class="version-dialog-footer">
                <a href="https://github.com/mateof/TelegramFileManager/releases" target="_blank" class="btn btn-sm btn-outline-secondary">
                    <i class="bi bi-github"></i> All Releases
                </a>
                <button class="btn btn-sm btn-secondary" @onclick="CloseVersionModal">Close</button>
            </div>
        </div>
    </div>
}

@code {
#nullable disable
#pragma warning disable BL0005 // Setting component parameters from code for modal pattern
    private Offcanvas offcanvas = default!;
    private Pages.Modals.ImportDataModal ImportModal { get; set; }
    private Pages.Modals.CreateChannelModal CreateChannelModal { get; set; }
    private Pages.Modals.AudioPlayerModal audioPlayer { get; set; } = default!;
    private Pages.Modals.UploadToTelegramModal uploadToTelegramModal { get; set; } = default!;
    private Pages.Modals.DeleteLeaveChannelModal deleteLeaveChannelModal { get; set; } = default!;
    private Pages.Modals.DatabaseMaintenanceModal databaseMaintenanceModal { get; set; } = default!;
    private Pages.Modals.PathRepairModal pathRepairModal { get; set; } = default!;
    private Pages.Modals.PlaylistManagerModal playlistManager { get; set; } = default!;
    private Pages.Modals.SaveToPlaylistModal saveToPlaylist { get; set; } = default!;
    private NavMenu menu { get; set; }
    private VersionBadge versionBadge { get; set; }
    private bool active { get; set; } = true;
    private bool sidebarCollapsed { get; set; } = false;
    private bool navMenuCollapsed { get; set; } = true;
    private bool showVersionModal { get; set; } = false;
    private static MainLayout? _instance;
    private bool _disposed = false;

    protected override void OnInitialized()
    {
        _instance = this;
    }

    [JSInvokable]
    public static async Task OpenAudioPlayer(string url, string type, string title)
    {
        try
        {
            if (_instance?.audioPlayer != null)
            {
                await _instance.audioPlayer.ShowModal(url, type, title);
            }
        }
        catch { }
    }

    [JSInvokable]
    public static async Task OpenAudioPlayerCurrent()
    {
        try
        {
            if (_instance?.audioPlayer != null)
            {
                await _instance.audioPlayer.ShowCurrentModal();
            }
        }
        catch { }
    }

    [JSInvokable]
    public static async Task AddToAudioPlaylist(string url, string type, string title)
    {
        try
        {
            if (_instance?.audioPlayer != null)
            {
                await _instance.audioPlayer.AddToPlaylist(url, type, title);
            }
        }
        catch { }
    }

    [JSInvokable]
    public static async Task AddToAudioPlaylistAndPlay(string url, string type, string title)
    {
        try
        {
            if (_instance?.audioPlayer != null)
            {
                await _instance.audioPlayer.AddToPlaylistAndPlay(url, type, title);
            }
        }
        catch { }
    }

    [JSInvokable]
    public static async Task AddMultipleToAudioPlaylist(PlaylistItemDto[] items)
    {
        try
        {
            if (_instance?.audioPlayer != null && items != null)
            {
                var playlistItems = items.Select(i => (i.url, i.type ?? "audio/mpeg", i.title ?? "")).ToList();
                await _instance.audioPlayer.AddMultipleToPlaylist(playlistItems);
            }
        }
        catch { }
    }

    public class PlaylistItemDto
    {
        public string url { get; set; } = string.Empty;
        public string? type { get; set; }
        public string? title { get; set; }
    }

    // Media Session API callbacks
    [JSInvokable]
    public static async Task MediaSessionAction(string action)
    {
        try
        {
            if (_instance?.audioPlayer == null) return;

            switch (action)
            {
                case "play":
                    await _instance.audioPlayer.ResumeFromMediaSession();
                    break;
                case "pause":
                    await _instance.audioPlayer.PauseFromMediaSession();
                    break;
                case "previoustrack":
                    await _instance.audioPlayer.PlayPreviousFromMediaSession();
                    break;
                case "nexttrack":
                    await _instance.audioPlayer.PlayNextFromMediaSession();
                    break;
                case "stop":
                    await _instance.audioPlayer.StopFromMediaSession();
                    break;
            }
        }
        catch { }
    }

    [JSInvokable]
    public static async Task MediaSessionSeek(double offsetSeconds)
    {
        try
        {
            if (_instance?.audioPlayer != null)
            {
                await _instance.audioPlayer.SeekRelativeFromMediaSession(offsetSeconds);
            }
        }
        catch { }
    }

    [JSInvokable]
    public static async Task MediaSessionSeekTo(double positionSeconds)
    {
        try
        {
            if (_instance?.audioPlayer != null)
            {
                await _instance.audioPlayer.SeekToFromMediaSession(positionSeconds);
            }
        }
        catch { }
    }

    // Método público para acceder al reproductor desde otros componentes
    public static Pages.Modals.AudioPlayerModal? GetAudioPlayer() => _instance?.audioPlayer;

    // Upload to Telegram Modal - static methods
    public static void OpenUploadToTelegramModal(string channelId, List<FileManagerDirectoryContent> files)
    {
        if (_instance?.uploadToTelegramModal != null)
        {
            _instance.uploadToTelegramModal.id = channelId;
            _instance.uploadToTelegramModal.Open(files);
        }
    }

    public static Pages.Modals.UploadToTelegramModal? GetUploadToTelegramModal() => _instance?.uploadToTelegramModal;

    // Delete/Leave Channel Modal - static methods
    public static void OpenDeleteLeaveChannelModal(string channelId, string channelName, bool isOwner)
    {
        if (_instance != null && _instance.deleteLeaveChannelModal != null)
        {
            _instance.InvokeAsync(() => _instance.deleteLeaveChannelModal.Open(channelId, channelName, isOwner));
        }
    }

    // Database Maintenance Modal - static methods
    public static void OpenDatabaseMaintenanceModal()
    {
        if (_instance != null && _instance.databaseMaintenanceModal != null)
        {
            _instance.InvokeAsync(async () => await _instance.databaseMaintenanceModal.Open());
        }
    }

    // Path Repair Modal - static methods
    public static void OpenPathRepairModal()
    {
        if (_instance != null && _instance.pathRepairModal != null)
        {
            _instance.InvokeAsync(async () => await _instance.pathRepairModal.Open());
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                if (!ts.checkUserLogin()) NavManager.NavigateTo("/", true);
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        // Check if setup is complete using async method to avoid deadlock
        var status = await SetupService.GetSetupStatusAsync();
        if (status.CurrentStep != SetupStep.Complete)
        {
            NavManager.NavigateTo("/setup", forceLoad: true);
            return;
        }

        await checkWorkingTasks();
        tis.TaskEventChanged += eventChangedWorkingTasks;
    }

    private async Task reloadMenu()
    {
        menu.RefreshChannels();
    }

    private async Task openOffCanvasMenu()
    {
        await offcanvas.ShowAsync(); 
    }

    private async Task openImportModalMenu()
    {
        await ImportModal.Open();
    }

    private void openCreateChannelModal()
    {
        CreateChannelModal?.Open();
    }

    private async Task openImportMenu()
    {
        await offcanvas.ShowAsync();
    }


    private void Notificar()
    {
        NotificationModel nm = new NotificationModel();
        nm.sendEvent(new Notification("<h1>Body message</h1>", "Title", NotificationTypes.Info));
    }

    private async Task Navigateto(string relativeUri)
    {
        await JS.InvokeVoidAsync("blurActiveElement");
        await offcanvas.HideAsync();
        NavManager.NavigateTo(relativeUri);
    }

    private async Task NavigateAndClose(string relativeUri)
    {
        await JS.InvokeVoidAsync("blurActiveElement");
        await offcanvas.HideAsync();
        NavManager.NavigateTo(relativeUri);
    }

    private async void Logout()
    {
        try
        {
            await ts.logOff();
            NavManager.NavigateTo("/");
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private async Task LogoutAndClose()
    {
        await JS.InvokeVoidAsync("blurActiveElement");
        await offcanvas.HideAsync();
        await ts.logOff();
        NavManager.NavigateTo("/");
    }

    private async Task OpenPlaylistsAndClose()
    {
        await JS.InvokeVoidAsync("blurActiveElement");
        await offcanvas.HideAsync();
        if (playlistManager != null)
        {
            await playlistManager.Open();
        }
    }

    private async Task checkWorkingTasks() {
        try
        {
            if (_disposed) return;
            active = tis.isWorking();
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private int GetDownloadProgress()
    {
        var activeDownload = tis.downloadModels.FirstOrDefault(x => x.state == StateTask.Working);
        return activeDownload?.progress ?? 0;
    }

    private int GetUploadProgress()
    {
        var activeUpload = tis.uploadModels.FirstOrDefault(x => x.state == StateTask.Working);
        return activeUpload?.progress ?? 0;
    }

    private async void eventChangedWorkingTasks(object sender, System.EventArgs e)
    {
        try
        {
            await checkWorkingTasks();
        }
        catch { }
    }

    private void ToggleSidebar()
    {
        sidebarCollapsed = !sidebarCollapsed;
    }

    private async void OnNavMenuCollapseChanged(bool isCollapsed)
    {
        try
        {
            navMenuCollapsed = isCollapsed;
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private async Task CloseVersionModal()
    {
        showVersionModal = false;
        if (versionBadge != null)
        {
            await versionBadge.CloseModal();
        }
    }

    // Playlist Manager Modal - static methods
    public static void OpenPlaylistManager()
    {
        if (_instance != null && _instance.playlistManager != null)
        {
            _instance.InvokeAsync(async () => await _instance.playlistManager.Open());
        }
    }

    public static Pages.Modals.PlaylistManagerModal? GetPlaylistManager() => _instance?.playlistManager;
    public static Pages.Modals.SaveToPlaylistModal? GetSaveToPlaylistModal() => _instance?.saveToPlaylist;

    public static void OpenPlaylistManagerWithPlaylist(string playlistId)
    {
        if (_instance != null && _instance.playlistManager != null)
        {
            _instance.InvokeAsync(async () => await _instance.playlistManager.OpenWithPlaylist(playlistId));
        }
    }

    // Playlist event handlers
    private async Task OnPlayPlaylist((Models.PlaylistModel playlist, int? startIndex) args)
    {
        if (audioPlayer == null || args.playlist.Tracks.Count == 0) return;

        // Convert playlist tracks to audio player format and add all to playlist
        var playlistItems = args.playlist.Tracks
            .OrderBy(t => t.Order)
            .Select(t => (
                Url: GetTrackUrl(t),
                Type: GetAudioMimeType(t.FileType),
                Title: t.FileName
            ))
            .ToList();

        // Clear current playlist and add all tracks
        await audioPlayer.ClearPlaylist();
        await audioPlayer.AddMultipleToPlaylist(playlistItems);

        // Set the playlist name and ID so it shows as active in the sidebar
        await audioPlayer.SetPlaylistName(args.playlist.Name, args.playlist.Id);

        // Show the modal first (in case it's not visible)
        await audioPlayer.ShowCurrentModal();

        // Play from start index or first track
        int startIdx = args.startIndex ?? 0;
        await audioPlayer.PlayTrack(startIdx);
    }

    private string GetTrackUrl(Models.PlaylistTrackModel track)
    {
        // Local files have DirectUrl set
        if (track.IsLocalFile)
        {
            return track.DirectUrl!;
        }

        // Telegram files - use GetFileByTfmId which supports cache
        return $"{NavManager.BaseUri}api/file/GetFileByTfmId/{track.FileName}?idChannel={track.ChannelId}&idFile={track.FileId}";
    }

    private string GetAudioMimeType(string fileType)
    {
        return fileType?.ToLower() switch
        {
            ".mp3" => "audio/mpeg",
            ".flac" => "audio/flac",
            ".wav" => "audio/wav",
            ".ogg" => "audio/ogg",
            ".m4a" => "audio/mp4",
            ".aac" => "audio/aac",
            _ => "audio/mpeg"
        };
    }

    private async Task OnDownloadPlaylist((Models.PlaylistModel playlist, string folder) args)
    {
        // Run download in background to not block UI
        _ = Task.Run(async () =>
        {
            try
            {
                await FileService.DownloadPlaylistToLocal(args.playlist, args.folder);
            }
            catch (Exception ex)
            {
                NotificationModel nm = new NotificationModel();
                nm.sendEvent(new Notification($"Error downloading playlist: {ex.Message}", "Playlist Download", NotificationTypes.Error));
            }
        });
    }

    private async Task OnPlaylistNotify(string message)
    {
        NotificationModel nm = new NotificationModel();
        nm.sendEvent(new Notification(message, "Playlist", NotificationTypes.Success));

        // Refresh audio player's saved playlists sidebar
        if (audioPlayer != null)
        {
            try
            {
                await audioPlayer.RefreshSavedPlaylists();
            }
            catch { }
        }
    }

    public void Dispose()
    {
        _disposed = true;
        tis.TaskEventChanged -= eventChangedWorkingTasks;
    }
}
