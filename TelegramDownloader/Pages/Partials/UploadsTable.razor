@using TelegramDownloader.Data
@using TelegramDownloader.Models
@using TelegramDownloader.Pages.Modals.InfoModals
@using TelegramDownloader.Services
@implements IDisposable

@inject TransactionInfoService tis

<Grid @ref="grid"
      TItem="UploadModel"
      Class="table"
      DataProvider="UploadsDataProvider"
      AllowFiltering="false"
      AllowPaging="true"
      AllowSorting="false"
      Responsive="true"
      ItemsPropertyName="_internalId">

    <GridColumn TItem="UploadModel" HeaderText="File" PropertyName="name" HeaderTextAlignment="Alignment.Start" TextAlignment="Alignment.Start">
        <div class="file-name">
            <div class="file-icon">
                <i class="bi @GetFileIcon(context.name)"></i>
            </div>
            <div class="file-info">
                <div class="file-title" title="@context.path">@context.name</div>
                <div class="file-action">
                    <i class="bi bi-arrow-up-circle"></i>
                    @context.action
                </div>
            </div>
        </div>
    </GridColumn>

    <GridColumn TItem="UploadModel" HeaderText="Progress" PropertyName="progress">
        <div class="progress-container">
            <div class="progress-wrapper">
                <div class="progress-stats">
                    <span class="progress-percent @(context.progress >= 100 ? "complete" : "")">@context.progress%</span>
                    <span class="progress-size">@context._transmittedString / @context._sizeString</span>
                </div>
                <div class="progress">
                    <div class="progress-bar @GetProgressClass(context)"
                         role="progressbar"
                         style="width: @context.progress%;"
                         aria-valuenow="@context.progress"
                         aria-valuemin="0"
                         aria-valuemax="100">
                    </div>
                </div>
            </div>
        </div>
    </GridColumn>

    <GridColumn TItem="UploadModel" HeaderText="Status">
        <span class="status-badge @GetStatusClass(context, isPending)">
            <i class="bi @GetStatusIcon(context, isPending)"></i>
            @GetStatusText(context, isPending)
        </span>
    </GridColumn>

    <GridColumn TItem="UploadModel" HeaderText="Actions">
        <div class="action-buttons">
            @if (IsSplitting(context) && context.state == StateTask.Working && !isPending)
            {
                <button class="action-btn splitting" disabled title="Splitting file...">
                    <i class="bi bi-scissors spin"></i>
                </button>
            }
            else if (context.state == StateTask.Working && !isPending)
            {
                <button class="action-btn cancel" @onclick="() => cancel(context)" title="Cancel">
                    <i class="bi bi-x-lg"></i>
                </button>
            }

            @if ((context.state == StateTask.Canceled || context.state == StateTask.Error) && !isPending)
            {
                <button class="action-btn retry" @onclick="() => retry(context)" title="Retry">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
            }

            @if (context.state == StateTask.Canceled || context.state == StateTask.Error || isPending)
            {
                <button class="action-btn delete" @onclick="() => deleteUpload(context)" title="Delete">
                    <i class="bi bi-trash3"></i>
                </button>
            }

            <button class="action-btn info" @onclick="() => infoModal.ShowModal(context)" title="Info">
                <i class="bi bi-info-lg"></i>
            </button>
        </div>
    </GridColumn>

</Grid>

<TelegramDownloader.Pages.Modals.InfoModals.UploadFileInfoModal @ref="infoModal" OnClose="OnModalClose"></TelegramDownloader.Pages.Modals.InfoModals.UploadFileInfoModal>

@code {
    [Parameter]
    public bool isPending { get; set; } = false;

    [Parameter]
    public EventCallback OnUploadModalClose { get; set; }

    public static List<UploadModel> lum = new List<UploadModel>();
    BlazorBootstrap.Grid<UploadModel> grid = default!;
    UploadFileInfoModal infoModal { get; set; }
    private bool _disposed = false;

    private string GetFileIcon(string fileName)
    {
        if (string.IsNullOrEmpty(fileName)) return "bi-file-earmark";

        var ext = Path.GetExtension(fileName)?.ToLower();
        return ext switch
        {
            ".mp4" or ".mkv" or ".avi" or ".mov" or ".wmv" or ".webm" => "bi-film",
            ".mp3" or ".wav" or ".flac" or ".aac" or ".ogg" or ".m4a" => "bi-music-note-beamed",
            ".jpg" or ".jpeg" or ".png" or ".gif" or ".bmp" or ".webp" => "bi-image",
            ".pdf" => "bi-file-earmark-pdf",
            ".doc" or ".docx" => "bi-file-earmark-word",
            ".xls" or ".xlsx" => "bi-file-earmark-excel",
            ".zip" or ".rar" or ".7z" or ".tar" or ".gz" => "bi-file-earmark-zip",
            _ => "bi-file-earmark"
        };
    }

    private bool IsSplitting(UploadModel um)
    {
        return um is SplitModel || um.action == "Splitting";
    }

    private bool IsMd5Calculating(UploadModel um)
    {
        return um is Md5Model || um.action == "MD5 Calc" || um is XxHashModel || um.action == "XxHash Calc";
    }

    private string GetProgressClass(UploadModel um)
    {
        if (um.state == StateTask.Completed || um.progress >= 100) return "complete";
        if (um.state == StateTask.Error || um.state == StateTask.Canceled) return "error";
        if (IsSplitting(um)) return "splitting";
        return "";
    }

    private string GetStatusClass(UploadModel um, bool isPending)
    {
        if (isPending) return "pending";
        if (IsSplitting(um) && um.state == StateTask.Working) return "splitting";
        if (IsMd5Calculating(um) && um.state == StateTask.Working) return "calculating";
        return um.state switch
        {
            StateTask.Working => "working",
            StateTask.Completed => "completed",
            StateTask.Error => "error",
            StateTask.Canceled => "canceled",
            _ => "pending"
        };
    }

    private string GetStatusIcon(UploadModel um, bool isPending)
    {
        if (isPending) return "bi-clock";
        if (IsSplitting(um) && um.state == StateTask.Working) return "bi-scissors";
        if (IsMd5Calculating(um) && um.state == StateTask.Working) return "bi-calculator";
        return um.state switch
        {
            StateTask.Working => "bi-arrow-up-circle",
            StateTask.Completed => "bi-check-circle",
            StateTask.Error => "bi-exclamation-circle",
            StateTask.Canceled => "bi-slash-circle",
            _ => "bi-clock"
        };
    }

    private string GetStatusText(UploadModel um, bool isPending)
    {
        if (isPending) return "In Queue";
        if (IsSplitting(um) && um.state == StateTask.Working) return "Splitting";
        if (IsMd5Calculating(um) && um.state == StateTask.Working) return um.action;
        return um.state switch
        {
            StateTask.Working => "Uploading",
            StateTask.Completed => "Completed",
            StateTask.Error => "Error",
            StateTask.Canceled => "Canceled",
            _ => "Pending"
        };
    }

    private async Task OnModalClose()
    {
        await grid.RefreshDataAsync();
        if (OnUploadModalClose.HasDelegate)
        {
            await OnUploadModalClose.InvokeAsync();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        checkNewEventsHandler();
        tis.EventChanged += eventChangedNew;
    }

    private async Task cancel(UploadModel um)
    {
        // um.thread.Interrupt();
        um.state = StateTask.Canceled;
        await InvokeAsync(StateHasChanged);
    }

    private async Task retry(UploadModel um)
    {
        // um.thread.Interrupt();
        // um.re
        await InvokeAsync(StateHasChanged);
    }

    private async Task deleteUpload(UploadModel um)
    {
        if (isPending)
        {
            tis.deletePendingUploadInList(um);
            return;
        }
        tis.deleteUploadInList(um);
    }

    private async Task<GridDataProviderResult<UploadModel>> UploadsDataProvider(GridDataProviderRequest<UploadModel> request)
    {
        await getUploadModels(request.PageNumber - 1, request.PageSize, lum.Count() == 0);
        int totalUploads = tis.getTotalUploads(isPending);
        return await Task.FromResult(new GridDataProviderResult<UploadModel> { Data = lum ?? new List<UploadModel>(), TotalCount = totalUploads });
    }

    private async Task getUploadModels(int pageNumber, int pageSize, bool mustCallEnventHandler = false)
    {
        lum = tis.GetUploadModels(pageNumber, pageSize, isPending);
        if (mustCallEnventHandler)
            checkNewEventsHandler();
    }

    private void checkNewEventsHandler()
    {
        if (lum != null)
            foreach (UploadModel um in lum)
            {
                if (um.progress != 100)
                    um.EventChanged += eventChangedUpload;
                else
                    um.EventChanged -= eventChangedUpload;
            }

    }

    void eventChangedUpload(object sender, UploadEventArgs e)
    {
        if (_disposed) return;
        grid.RefreshDataAsync();
    }

    void eventChangedNew(object sender, System.EventArgs e)
    {
        if (_disposed) return;
        checkNewEventsHandler();
        grid.RefreshDataAsync();
    }

    public void Dispose()
    {
        _disposed = true;
        tis.EventChanged -= eventChangedNew;
        if (lum != null)
        {
            foreach (UploadModel um in lum)
            {
                um.EventChanged -= eventChangedUpload;
            }
        }
    }
}
