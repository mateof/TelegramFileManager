@using System.Web
@using TelegramDownloader.Data
@using TelegramDownloader.Models
@using TelegramDownloader.Pages.Modals
@using TelegramDownloader.Pages.Modals.InfoModals
@using TelegramDownloader.Shared.MobileFileManager
@inject HttpClient httpClient;
@inject IJSRuntime JSRuntime;
@inject NavigationManager MyNavigationManager;
@inject IFileService fs;
@inject ITelegramService ts;
@inject ILogger<FileManager> Logger;
@inject NavigationManager NavManager

@* Loading while detecting viewport and base URL *@
@if (!_viewportDetected || string.IsNullOrEmpty(_baseUrl))
{
    <div style="display: flex; justify-content: center; align-items: center; height: 200px;">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}

@* Desktop FileManager - only render when viewport detected, base URL ready, and not on mobile *@
@if (_viewportDetected && !string.IsNullOrEmpty(_baseUrl) && !_isMobileView)
{
    <SfFileManager @ref="FileManager" ID="localfm" TValue="FileManagerDirectoryContent">
        <FileManagerAjaxSettings Url="@FileOperationsUrl"
                                 UploadUrl="@UploadUrl"
                                 DownloadUrl="@DownloadUrl"
                                 GetImageUrl="@GetImageUrl">
        </FileManagerAjaxSettings>
        <FileManagerSearchSettings FilterDelay="1200"></FileManagerSearchSettings>
        <FileManagerUploadSettings MaxFileSize="@(long.MaxValue)" AutoUpload="true"></FileManagerUploadSettings>
        <FileManagerToolbarSettings ToolbarItems="@Items"></FileManagerToolbarSettings>
        <FileManagerContextMenuSettings File="@ContextItems"></FileManagerContextMenuSettings>
        <FileManagerEvents TValue="FileManagerDirectoryContent" FileSelection="FileSelection" ToolbarItemClicked="toolBarClicked" OnFileOpen="fileOpen" MenuOpened="MenuOpened" OnMenuClick="OnMenuClick"></FileManagerEvents>
    </SfFileManager>
}

@* Mobile FileManager *@
@if (_viewportDetected && !string.IsNullOrEmpty(_baseUrl) && _isMobileView)
{
    <div class="mobile-fm-container">
        <MobileFileManager @ref="mobileFileManager"
                           Id="@id"
                           IsShared="@isShared"
                           CanCopy="true"
                           CanCut="true"
                           CanDelete="true"
                           CanRename="true"
                           CanCreate="true"
                           CanUpload="true"
                           CanUploadToTelegram="@isMyChannel"
                           CanShowUrlMedia="true"
                           InitialSearch="@_initialSearch"
                           InitialFilters="@_initialFilters"
                           InitialSortBy="@_initialSortBy"
                           InitialSortAscending="@_initialSortAscending"
                           InitialPage="@_initialPage"
                           OnRead="OnMobileReadAsync"
                           OnItemsDeleting="OnMobileItemsDeletingAsync"
                           OnItemsMoving="OnMobileItemsMovingAsync"
                           OnItemRenaming="OnMobileItemRenamingAsync"
                           OnFolderCreating="OnMobileFolderCreatingAsync"
                           OnSearching="OnMobileSearchingAsync"
                           OnFileOpen="OnMobileFileOpenAsync"
                           OnBeforeDownload="OnMobileBeforeDownloadAsync"
                           OnUploadToTelegram="OnMobileUploadToTelegramAsync"
                           OnUploadToLocal="OnMobileUploadToLocalAsync"
                           OnUrlMedia="OnMobileUrlMediaAsync"
                           CanAddToPlaylist="true"
                           OnAddToPlaylist="OnMobileAddToPlaylistAsync"
                           OnPathChanged="OnMobilePathChanged"
                           OnFilterChanged="OnMobileFilterChanged" />
    </div>
}

<TelegramDownloader.Pages.Modals.FileUploadModal @ref="ModalUpSer"></TelegramDownloader.Pages.Modals.FileUploadModal>
<TelegramDownloader.Pages.Modals.InfoModals.MediaUrlModal @ref="mediaUrlModal"></TelegramDownloader.Pages.Modals.InfoModals.MediaUrlModal>
<TelegramDownloader.Pages.Modals.VideoPlayerModal @ref=videoPlayer></TelegramDownloader.Pages.Modals.VideoPlayerModal>
<TelegramDownloader.Pages.Modals.PdfViewerModal @ref="pdfViewer"></TelegramDownloader.Pages.Modals.PdfViewerModal>
<TelegramDownloader.Pages.Modals.ImageViewerModal @ref="imageViewer"></TelegramDownloader.Pages.Modals.ImageViewerModal>


@code {
#nullable disable
#pragma warning disable BL0005 // Setting component parameters from code for modal pattern
    const string param = "path";
    [Parameter]
    public string id { get; set; }
    [Parameter]
    public bool isShared { get; set; } = false;

    SfFileManager<FileManagerDirectoryContent>? FileManager;
    private MobileFileManager? mobileFileManager;

    // Static instance for JSInvokable
    private static LocalFileManagerImpl? _currentInstance;

    private MediaUrlModal mediaUrlModal { get; set; } = default!;
    private VideoPlayerModal videoPlayer { get; set; } = default!;
    private PdfViewerModal pdfViewer { get; set; } = default!;
    private ImageViewerModal imageViewer { get; set; } = default!;

    NotificationModel nm = new NotificationModel();
    public string[] ContextItems = new string[] { "Open", "Delete", "Download", "Rename", "Details", "Copy Media Url", "Add to Playlist" };

    private Modals.FileUploadModal ModalUpSer { get; set; }
    private bool isMyChannel = false;

    // Mobile detection
    private bool _isMobileView = false;
    private bool _viewportDetected = false;
    private const int MobileBreakpoint = 1920; // Custom breakpoint for mobile file manager

    // URLs will be set from JavaScript to get the actual browser origin
    private string _baseUrl = "";
    private string FileOperationsUrl => $"{_baseUrl}/api/file/FileOperations";
    private string UploadUrl => $"{_baseUrl}/api/file/Upload";
    private string DownloadUrl => $"{_baseUrl}/api/file/Download";
    private string GetImageUrl => $"{_baseUrl}/api/file/GetImage";


    public List<ToolBarItemModel> Items = new List<ToolBarItemModel>(){
        new ToolBarItemModel() { Name = "NewFolder" },
        new ToolBarItemModel() { Name = "Cut" },
        new ToolBarItemModel() { Name = "Copy" },
        new ToolBarItemModel() { Name = "Paste" },
        new ToolBarItemModel() { Name = "Delete" },
        new ToolBarItemModel() { Name = "Download" },
        // new ToolBarItemModel() { Name = "Upload" },
        new ToolBarItemModel() { Name = "Rename" },
        new ToolBarItemModel() { Name = "SortBy" },
        new ToolBarItemModel() { Name = "Refresh" },
        new ToolBarItemModel() { Name = "Selection" },
        new ToolBarItemModel() { Name = "View" },
        new ToolBarItemModel() { Name = "Details" },
        new ToolBarItemModel() { Name = "UrlMedia", Text = "Url Media", TooltipText = "Url Media", PrefixIcon = "bi bi-collection-play-fill", Visible = false }
    };

    private string _previousId;
    private bool _firstRenderComplete = false;
    private bool _needsRefresh = false;

    // URL state for filters, search, sorting, and pagination
    private string _initialSearch = string.Empty;
    private HashSet<string> _initialFilters = new();
    private string _initialSortBy = "Name";
    private bool _initialSortAscending = true;
    private int _initialPage = 1;
    private string _currentSearch = string.Empty;
    private HashSet<string> _currentFilters = new();
    private string _currentSortBy = "Name";
    private bool _currentSortAscending = true;
    private int _currentPage = 1;

    protected override async Task OnParametersSetAsync()
    {
        // Parse URL params early so they're available before first render
        if (!_firstRenderComplete)
        {
            ParseUrlParameters();
        }

        if (_previousId != id)
        {
            _previousId = id;
            await LoadDataAsync();

            // Solo marcar refresh si ya pasó el primer render
            if (_firstRenderComplete)
            {
                _needsRefresh = true;
            }
        }
    }

    private void ParseUrlParameters()
    {
        try
        {
            var uri = new Uri(MyNavigationManager.Uri);
            var query = HttpUtility.ParseQueryString(uri.Query);
            var searchFromUrl = query["search"];
            var filtersFromUrl = query["filters"];
            var sortByFromUrl = query["sortBy"];
            var sortAscFromUrl = query["sortAsc"];
            var pageFromUrl = query["page"];

            // Parse initial search
            if (!string.IsNullOrEmpty(searchFromUrl))
            {
                _initialSearch = Uri.UnescapeDataString(searchFromUrl);
                _currentSearch = _initialSearch;
            }

            // Parse initial filters (comma-separated)
            if (!string.IsNullOrEmpty(filtersFromUrl))
            {
                var filterList = Uri.UnescapeDataString(filtersFromUrl).Split(',', StringSplitOptions.RemoveEmptyEntries);
                _initialFilters = new HashSet<string>(filterList);
                _currentFilters = new HashSet<string>(filterList);
            }

            // Parse initial sort
            if (!string.IsNullOrEmpty(sortByFromUrl))
            {
                _initialSortBy = Uri.UnescapeDataString(sortByFromUrl);
                _currentSortBy = _initialSortBy;
            }

            if (!string.IsNullOrEmpty(sortAscFromUrl))
            {
                _initialSortAscending = sortAscFromUrl.ToLower() != "false";
                _currentSortAscending = _initialSortAscending;
            }

            // Parse initial page
            if (!string.IsNullOrEmpty(pageFromUrl) && int.TryParse(pageFromUrl, out int page) && page > 0)
            {
                _initialPage = page;
                _currentPage = page;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error parsing URL parameters");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _firstRenderComplete = true;
            _currentInstance = this;

            // Get actual browser origin via JavaScript (works correctly with reverse proxies)
            _baseUrl = await JSRuntime.InvokeAsync<string>("eval", "window.location.origin");
            Logger.LogInformation($"LocalFileManager BaseUrl: {_baseUrl}");

            // Detect viewport size on first render
            await DetectMobileView();

            // Force re-render to apply the URLs
            StateHasChanged();
        }

        if (_needsRefresh && FileManager != null)
        {
            _needsRefresh = false;
            FileManager.Path = "/";
            try
            {
                await FileManager.RefreshFilesAsync();
            } catch(Exception ex)
            {
                Logger.LogError(ex, "Error on  FileManager.RefreshFilesAsync()");
                nm.sendMessage("Error", "Error on  FileManager.RefreshFilesAsync()", NotificationTypes.Error);
            }

        }

        // Navigate to path from URL after components are rendered
        if (_pendingPathNavigation)
        {
            _pendingPathNavigation = false;
            // Small delay to ensure components are fully initialized
            await Task.Delay(100);
            await NavigateToPathFromUrl();
        }
    }

    private async Task DetectMobileView()
    {
        try
        {
            // Check if config forces mobile file manager
            if (GeneralConfigStatic.config.UseMobileFileManagerAlways)
            {
                _isMobileView = true;
            }
            else
            {
                var width = await JSRuntime.InvokeAsync<int>("eval", "window.innerWidth");
                _isMobileView = width < MobileBreakpoint;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error detecting viewport size");
            _isMobileView = false;
        }
        finally
        {
            _viewportDetected = true;
            _pendingPathNavigation = true;
            StateHasChanged();
        }
    }

    private bool _pendingPathNavigation = false;

    private async Task NavigateToPathFromUrl()
    {
        try
        {
            var uri = new Uri(MyNavigationManager.Uri);
            var query = HttpUtility.ParseQueryString(uri.Query);
            var pathFromUrl = query["path"];

            if (string.IsNullOrEmpty(pathFromUrl))
                return;

            // Decode the path and ensure it ends with /
            var decodedPath = Uri.UnescapeDataString(pathFromUrl);
            if (!decodedPath.EndsWith("/"))
                decodedPath += "/";

            // Handle mobile file manager
            if (_isMobileView && mobileFileManager != null)
            {
                await mobileFileManager.NavigateToPathSilent(decodedPath);
            }
            // Handle desktop file manager
            else if (!_isMobileView && FileManager != null)
            {
                FileManager.Path = decodedPath;
                await FileManager.RefreshFilesAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error navigating to path from URL");
        }
    }

    private void OnMobilePathChanged(string path)
    {
        // Reset page when navigating to a different folder
        _currentPage = 1;
        UpdateUrlWithState(path, _currentSearch, _currentFilters, _currentSortBy, _currentSortAscending, _currentPage);
    }

    private void OnMobileFilterChanged(MfmFilterChangedEventArgs args)
    {
        _currentSearch = args.SearchText;
        _currentFilters = args.TypeFilters;
        _currentSortBy = args.SortBy;
        _currentSortAscending = args.SortAscending;
        _currentPage = args.CurrentPage;

        var path = mobileFileManager?.Path ?? "/";
        UpdateUrlWithState(path, _currentSearch, _currentFilters, _currentSortBy, _currentSortAscending, _currentPage);
    }

    private void UpdateUrlWithState(string path, string search, HashSet<string> filters, string sortBy = "Name", bool sortAscending = true, int page = 1)
    {
        try
        {
            var baseUri = MyNavigationManager.Uri.Split('?')[0];
            var queryParams = new List<string>();

            // Add path if not root
            if (path != "/")
            {
                queryParams.Add($"path={Uri.EscapeDataString(path)}");
            }

            // Add search if not empty
            if (!string.IsNullOrEmpty(search))
            {
                queryParams.Add($"search={Uri.EscapeDataString(search)}");
            }

            // Add filters if any selected
            if (filters.Count > 0)
            {
                queryParams.Add($"filters={Uri.EscapeDataString(string.Join(",", filters))}");
            }

            // Add sortBy if not default
            if (sortBy != "Name")
            {
                queryParams.Add($"sortBy={Uri.EscapeDataString(sortBy)}");
            }

            // Add sortAsc if not default (ascending)
            if (!sortAscending)
            {
                queryParams.Add("sortAsc=false");
            }

            // Add page if not first page
            if (page > 1)
            {
                queryParams.Add($"page={page}");
            }

            var newUrl = queryParams.Count > 0
                ? $"{baseUri}?{string.Join("&", queryParams)}"
                : baseUri;

            MyNavigationManager.NavigateTo(newUrl, forceLoad: false, replace: true);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating URL with state");
        }
    }

    public async Task RefreshFileManager()
    {
        // Refresh desktop FileManager
        if (FileManager != null)
        {
            await FileManager.RefreshFilesAsync();
        }

        // Refresh mobile FileManager
        if (mobileFileManager != null)
        {
            await mobileFileManager.RefreshFilesAsync();
        }
    }

    [JSInvokable]
    public static async Task RefreshFileManagerStatic()
    {
        try
        {
            if (_currentInstance != null)
            {
                await _currentInstance.InvokeAsync(async () =>
                {
                    await _currentInstance.RefreshFileManager();
                });
            }
        }
        catch { }
    }

    private async Task LoadDataAsync()
    {
        if (!isShared)
        {
            isMyChannel = ts.isMyChat(Convert.ToInt64(id));

            // Reset Items to base items
            Items = new List<ToolBarItemModel>(){
                new ToolBarItemModel() { Name = "NewFolder" },
                new ToolBarItemModel() { Name = "Cut" },
                new ToolBarItemModel() { Name = "Copy" },
                new ToolBarItemModel() { Name = "Paste" },
                new ToolBarItemModel() { Name = "Delete" },
                new ToolBarItemModel() { Name = "Download" },
                new ToolBarItemModel() { Name = "Rename" },
                new ToolBarItemModel() { Name = "SortBy" },
                new ToolBarItemModel() { Name = "Refresh" },
                new ToolBarItemModel() { Name = "Selection" },
                new ToolBarItemModel() { Name = "View" },
                new ToolBarItemModel() { Name = "Details" },
                new ToolBarItemModel() { Name = "UrlMedia", Text = "Url Media", TooltipText = "Url Media", PrefixIcon = "bi bi-collection-play-fill", Visible = false }
            };

            if (isMyChannel)
            {
                Items.AddRange(new List<ToolBarItemModel>(){
                    new ToolBarItemModel() { Name = "Upload File", Text = "Upload To Local", TooltipText = "Upload To local", PrefixIcon = "e-icons e-fe-upload" },
                    new ToolBarItemModel() { Name = "UploadTelegram", Text = "Upload Telegram", TooltipText = "Upload File", PrefixIcon = "bi bi-telegram" },

                    }
                );
            } else
            {
                Items.AddRange(new List<ToolBarItemModel>(){
                    new ToolBarItemModel() { Name = "Upload File", Text = "Upload To Local", TooltipText = "Upload To local", PrefixIcon = "e-icons e-fe-upload" }

                    }
                );
            }

        }
        try
        {
            if (!isShared)
                await fs.CreateDatabase(id);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on CreateDatabase");
            nm.sendMessage("Error", "Error on CreateDatabase", NotificationTypes.Error);
        }

    }

    // Uncomment for url navigate
    // protected override async Task OnAfterRenderAsync(bool firstRender)
    // {
    //     if (firstRender)
    //     {
    //         var paramValue = getParamFromUrl("path", MyNavigationManager.Uri);

    //         if (!string.IsNullOrEmpty(paramValue))
    //         {
    //             FileManager.Path = paramValue;
    //             // FileManager.RefreshFilesAsync();
    //         }
    //         MyNavigationManager.LocationChanged += OnLocationChanged;
    //     }
    // }

    // private void OnLocationChanged(object sender, LocationChangedEventArgs e)
    // {
    //     var route = getParamFromUrl(param, e.Location);
    //     if (route != FileManager.Path)
    //     {
    //         var paramValue = getParamFromUrl(param, MyNavigationManager.Uri);

    //         if (!string.IsNullOrEmpty(paramValue))
    //         {
    //             FileManager.Path = Uri.EscapeUriString(paramValue);
    //             //FileManager.RefreshFilesAsync();
    //         }
    //     }
    // }

    // private string getParamFromUrl(string param, string url)
    // {
    //     var uri = MyNavigationManager.ToAbsoluteUri(url);
    //     var queryParams = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(uri.Query);
    //     if (queryParams.TryGetValue(param, out var paramValue))
    //     {
    //         return paramValue;
    //     }
    //     return "";
    // }

    // public async Task fileLoad(ReadEventArgs<FileManagerDirectoryContent> args)
    // {
    //     try
    //     {
    //         var paramValue = getParamFromUrl(param, MyNavigationManager.Uri);


    //         if (string.IsNullOrEmpty(paramValue) || FileManager.Path != Uri.EscapeUriString(paramValue))
    //         {
    //             var url = MyNavigationManager.Uri.Split('?')[0]; // Obtener la URL base sin parámetros
    //             MyNavigationManager.NavigateTo($"{url}?path={FileManager.Path}", forceLoad: false, replace: false);
    //         }
    //     }
    //     catch (Exception ex)
    //     {

    //     }


    // }


    public void FileSelection(FileSelectionEventArgs<FileManagerDirectoryContent> args)
    {
        List<FileManagerDirectoryContent> selectedList = FileManager.GetSelectedFiles();
        if ((selectedList.Count() + (args.Action == "UnSelect" ? -1 : 1)) == 1)
        {
            if (args.FileDetails.IsFile)
            {
                Items.Where(x => x.Name == "UrlMedia").FirstOrDefault().Visible = true;
                return;
            }

        }
        Items.Where(x => x.Name == "UrlMedia").FirstOrDefault().Visible = false;
    }

    public async Task fileOpen(FileOpenEventArgs<FileManagerDirectoryContent> args)
    {
        if (args != null && args.FileDetails != null && args.FileDetails.IsFile && IsAudioFile(args.FileDetails.Type.ToLower()))
        {
            await playAudio(args);
        }
        else if (args != null && args.FileDetails != null && args.FileDetails.IsFile && isVideoFile(args.FileDetails.Type.ToLower()))
        {
            string path = getLocalVideoUrl(args.FileDetails.FilterPath, args.FileDetails.Name);
            videoPlayer.ShowModal(path);
        }
        else if (args != null && args.FileDetails != null && args.FileDetails.IsFile && isPdfFile(args.FileDetails.Type.ToLower()))
        {
            string path = getLocalFileUrl(args.FileDetails.FilterPath, args.FileDetails.Name);
            await pdfViewer.ShowModal(path, args.FileDetails.Name);
        }
        else if (args != null && args.FileDetails != null && args.FileDetails.IsFile && isImageFile(args.FileDetails.Type.ToLower()))
        {
            await OpenLocalImageViewer(args.FileDetails);
        }
    }

    private async Task playAudio(FileOpenEventArgs<FileManagerDirectoryContent> args)
    {
        string localdir = MyNavigationManager.BaseUri + FileService.STATICRELATIVELOCALDIR.Replace("\\", "/");
        string path = new System.Uri((Path.Combine(localdir, args.FileDetails.FilterPath.Substring(1).Replace("\\", "/"), args.FileDetails.Name)).Replace("\\", "/")).AbsoluteUri;
        await JSRuntime.InvokeVoidAsync("openAudioPlayerModal", path, null, args.FileDetails.Name);
    }

    public void MenuOpened(MenuOpenEventArgs<FileManagerDirectoryContent> args)
    {
        if (args.FileDetails.Count() == 1)
        {

        }
        // for (int i = 0; i < args.FileDetails.Count(); i++)
        // {
        //     if (!args.FileDetails[i].IsFile)
        //     {
        //         for (int j = 0; j < args.Items.Count(); j++)
        //         {
        //             if (args.Items[j].Text == "Cut")
        //             {
        //                 args.Items[j].Disabled = true;
        //             }
        //         }
        //     }
        //     else
        //     {
        //         for (int j = 0; j < args.Items.Count(); j++)
        //         {
        //             if (args.Items[j].Disabled == true)
        //             {
        //                 args.Items[j].Disabled = false;
        //             }
        //         }
        //     }
        // }

    }

    public async Task OnMenuClick(MenuClickEventArgs<FileManagerDirectoryContent> args)
    {
        if (args.FileDetails.Count() == 1)
        {
            if (args.Item.Text == "Copy Media Url")
            {
                await ShowMediaURLModal(args.FileDetails[0].FilterPath, args.FileDetails[0].Name);
            }
            if (args.Item.Text == "Add to Playlist")
            {
                var file = args.FileDetails[0];
                if (file.IsFile && IsAudioFile(file.Type?.ToLower() ?? ""))
                {
                    string localdir = MyNavigationManager.BaseUri + FileService.STATICRELATIVELOCALDIR.Replace("\\", "/");
                    string url = new System.Uri((Path.Combine(localdir, file.FilterPath.Substring(1).Replace("\\", "/"), file.Name)).Replace("\\", "/")).AbsoluteUri;
                    await JSRuntime.InvokeVoidAsync("addToAudioPlaylist", url, null, file.Name);
                    nm.sendMessage("Playlist", $"Added '{file.Name}' to playlist", NotificationTypes.Success);
                }
            }
        }
    }

    private bool IsAudioFile(string fileExtension)
    {
        return new List<string> { ".mp3", ".ogg", ".flac", ".aac", ".wav" }.Contains(fileExtension);
    }

    private bool isVideoFile(string fileExtension)
    {
        // Native browser formats - always playable
        var nativeFormats = new List<string> { ".mov", ".mp4", ".m4v", ".ogv", ".webm", ".flv", ".f4v" };

        if (nativeFormats.Contains(fileExtension))
            return true;

        // Transcoding formats - only playable if transcoding is enabled
        if (GeneralConfigStatic.config.EnableVideoTranscoding)
        {
            var transcodingFormats = new List<string> { ".mkv", ".avi", ".wmv", ".ts", ".mts", ".m2ts", ".vob", ".divx", ".xvid", ".3gp" };
            return transcodingFormats.Contains(fileExtension);
        }

        return false;
    }

    private bool needsTranscoding(string fileExtension)
    {
        return new List<string> { ".mkv", ".avi", ".wmv", ".ts", ".mts", ".m2ts", ".vob", ".divx", ".xvid", ".3gp" }.Contains(fileExtension);
    }

    private bool isPdfFile(string fileExtension)
    {
        return fileExtension == ".pdf";
    }

    private bool isImageFile(string fileExtension)
    {
        return new List<string> { ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".svg", ".ico", ".tiff", ".tif" }.Contains(fileExtension);
    }

    private async Task OpenLocalImageViewer(FileManagerDirectoryContent clickedImage)
    {
        try
        {
            // Get current path from desktop file manager
            var currentPath = FileManager?.Path ?? "/";

            // Get all files in current folder using the file operations API
            var response = await CallFileOperationsAsync("read", currentPath, null);

            // Filter to only images and build ImageInfo list
            var imageFiles = response?.Files?
                .Where(f => f.IsFile && isImageFile(f.Type?.ToLower() ?? ""))
                .OrderBy(f => f.Name)
                .ToList() ?? new List<FileManagerDirectoryContent>();

            if (imageFiles.Count == 0)
            {
                // Fallback: just show the clicked image
                string url = getLocalFileUrl(clickedImage.FilterPath, clickedImage.Name);
                await imageViewer.ShowModal(url, clickedImage.Name);
                return;
            }

            // Build list of ImageInfo
            var imageInfoList = new List<ImageViewerModal.ImageInfo>();
            int startIndex = 0;

            for (int i = 0; i < imageFiles.Count; i++)
            {
                var file = imageFiles[i];
                string url = getLocalFileUrl(file.FilterPath, file.Name);
                imageInfoList.Add(new ImageViewerModal.ImageInfo { Url = url, FileName = file.Name });

                if (file.Name == clickedImage.Name)
                {
                    startIndex = i;
                }
            }

            await imageViewer.ShowModal(imageInfoList, startIndex);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error opening local image viewer");
            // Fallback: just show the clicked image
            string url = getLocalFileUrl(clickedImage.FilterPath, clickedImage.Name);
            await imageViewer.ShowModal(url, clickedImage.Name);
        }
    }

    private async Task OpenLocalImageViewerMobile(FileManagerDirectoryContent clickedImage)
    {
        try
        {
            // Get current path from mobile file manager
            var currentPath = mobileFileManager?.Path ?? "/";

            // Get all files in current folder using the file operations API
            var response = await CallFileOperationsAsync("read", currentPath, null);

            // Filter to only images and build ImageInfo list
            var imageFiles = response?.Files?
                .Where(f => f.IsFile && isImageFile(f.Type?.ToLower() ?? ""))
                .OrderBy(f => f.Name)
                .ToList() ?? new List<FileManagerDirectoryContent>();

            if (imageFiles.Count == 0)
            {
                // Fallback: just show the clicked image
                string url = getLocalFileUrl(clickedImage.FilterPath, clickedImage.Name);
                await imageViewer.ShowModal(url, clickedImage.Name);
                return;
            }

            // Build list of ImageInfo
            var imageInfoList = new List<ImageViewerModal.ImageInfo>();
            int startIndex = 0;

            for (int i = 0; i < imageFiles.Count; i++)
            {
                var file = imageFiles[i];
                string url = getLocalFileUrl(file.FilterPath, file.Name);
                imageInfoList.Add(new ImageViewerModal.ImageInfo { Url = url, FileName = file.Name });

                if (file.Name == clickedImage.Name)
                {
                    startIndex = i;
                }
            }

            await imageViewer.ShowModal(imageInfoList, startIndex);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error opening local image viewer (mobile)");
            // Fallback: just show the clicked image
            string url = getLocalFileUrl(clickedImage.FilterPath, clickedImage.Name);
            await imageViewer.ShowModal(url, clickedImage.Name);
        }
    }

    private string getLocalFileUrl(string filterPath, string name)
    {
        string localdir = MyNavigationManager.BaseUri + FileService.STATICRELATIVELOCALDIR.Replace("\\", "/");
        return new System.Uri((Path.Combine(localdir, filterPath.Substring(1).Replace("\\", "/"), name)).Replace("\\", "/")).AbsoluteUri;
    }

    private string getLocalVideoUrl(string filterPath, string name)
    {
        var extension = Path.GetExtension(name).ToLowerInvariant();
        string localdir = MyNavigationManager.BaseUri + FileService.STATICRELATIVELOCALDIR.Replace("\\", "/");

        if (needsTranscoding(extension))
        {
            // Use transcoding endpoint
            var relativePath = filterPath.Substring(1).Replace("\\", "/") + name;
            return $"{_baseUrl}/api/localvideo/stream?path={Uri.EscapeDataString(relativePath)}";
        }

        // Use direct static file
        return new System.Uri((Path.Combine(localdir, filterPath.Substring(1).Replace("\\", "/"), name)).Replace("\\", "/")).AbsoluteUri;
    }

    private async Task ShowMediaURLModal(string FilterPath, string Name)
    {
        string localdir = MyNavigationManager.BaseUri + FileService.STATICRELATIVELOCALDIR.Replace("\\", "/");
        string path = new System.Uri((Path.Combine(localdir, FilterPath.Substring(1).Replace("\\", "/"), Name)).Replace("\\", "/")).AbsoluteUri;
        mediaUrlModal.url = path;
        await mediaUrlModal.OnShowModalClick();
    }


    public async Task toolBarClicked(ToolbarClickEventArgs<FileManagerDirectoryContent> args)
    {
        if (args.Item.Text == "Upload Telegram" && args.FileDetails.Count() > 0)
        {
            MainLayout.OpenUploadToTelegramModal(id, args.FileDetails.ToList());
        }

        if (args.Item.Text == "Upload To Local" && args.FileDetails.Count() > 0)
        {
            ModalUpSer.id = id;
            ModalUpSer.url = "/api/file/Upload";
            ModalUpSer.filePath = args.FileDetails.FirstOrDefault().IsFile ? args.FileDetails.FirstOrDefault().FilterPath.Replace("\\", "/") + args.FileDetails.FirstOrDefault().Name : args.FileDetails.FirstOrDefault().FilterPath.Replace("\\", "/") + args.FileDetails.FirstOrDefault().Name + "/";
            ModalUpSer.Open();
        }

        if (args.Item.Text == "Url Media" && args.FileDetails.Count() > 0)
        {
            await ShowMediaURLModal(args.FileDetails[0].FilterPath, args.FileDetails[0].Name);
        }
    }

    #region Mobile FileManager Event Handlers

    private async Task OnMobileReadAsync(MfmReadEventArgs args)
    {
        try
        {
            var response = await CallFileOperationsAsync("read", args.Path, null);
            args.Response = response;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error reading files for mobile");
        }
    }

    private async Task OnMobileItemsDeletingAsync(MfmDeleteEventArgs args)
    {
        try
        {
            await CallFileOperationsAsync("delete", args.Path, args.Files);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting files for mobile");
            nm.sendMessage("Error", "Error deleting files", NotificationTypes.Error);
        }
    }

    private async Task OnMobileItemsMovingAsync(MfmMoveEventArgs args)
    {
        try
        {
            var action = args.IsCopy ? "copy" : "move";
            // Normalize paths to use forward slashes
            var sourcePath = args.SourcePath?.Replace("\\", "/") ?? "/";
            var targetPath = args.TargetPath?.Replace("\\", "/") ?? "/";

            // Also normalize FilterPath in files
            var normalizedFiles = args.Files.Select(f => {
                f.FilterPath = f.FilterPath?.Replace("\\", "/");
                return f;
            }).ToArray();

            var targetData = args.TargetData;
            if (targetData != null)
            {
                targetData.FilterPath = targetData.FilterPath?.Replace("\\", "/");
            }

            await CallFileOperationsAsync(action, sourcePath, normalizedFiles, targetPath, targetData);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error moving/copying files for mobile");
            nm.sendMessage("Error", "Error moving/copying files", NotificationTypes.Error);
        }
    }

    private async Task OnMobileItemRenamingAsync(MfmRenameEventArgs args)
    {
        try
        {
            if (args.File != null)
            {
                await CallFileOperationsAsync("rename", args.Path, new[] { args.File }, newName: args.NewName);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error renaming file for mobile");
            nm.sendMessage("Error", "Error renaming file", NotificationTypes.Error);
        }
    }

    private async Task OnMobileFolderCreatingAsync(MfmFolderCreateEventArgs args)
    {
        try
        {
            await CallFileOperationsAsync("create", args.Path, null, newName: args.FolderName);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating folder for mobile");
            nm.sendMessage("Error", "Error creating folder", NotificationTypes.Error);
        }
    }

    private async Task OnMobileSearchingAsync(MfmSearchEventArgs args)
    {
        try
        {
            // Wrap search text with wildcards for "contains" search behavior
            // The FileManagerService uses wildcard pattern matching where * matches any sequence
            var searchPattern = $"*{args.SearchText}*";
            var response = await CallFileOperationsAsync("search", args.Path, null, searchString: searchPattern);
            args.Response = response;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error searching files for mobile");
        }
    }

    private async Task OnMobileFileOpenAsync(MfmFileOpenEventArgs args)
    {
        if (args.FileDetails == null || !args.FileDetails.IsFile) return;

        var fileType = args.FileDetails.Type?.ToLower() ?? "";

        if (IsAudioFile(fileType))
        {
            string localdir = MyNavigationManager.BaseUri + FileService.STATICRELATIVELOCALDIR.Replace("\\", "/");
            string path = new System.Uri((Path.Combine(localdir, args.FileDetails.FilterPath.Substring(1).Replace("\\", "/"), args.FileDetails.Name)).Replace("\\", "/")).AbsoluteUri;
            await JSRuntime.InvokeVoidAsync("openAudioPlayerModal", path, null, args.FileDetails.Name);
        }
        else if (isVideoFile(fileType))
        {
            string path = getLocalVideoUrl(args.FileDetails.FilterPath, args.FileDetails.Name);
            videoPlayer.ShowModal(path);
        }
        else if (isPdfFile(fileType))
        {
            string path = getLocalFileUrl(args.FileDetails.FilterPath, args.FileDetails.Name);
            await pdfViewer.ShowModal(path, args.FileDetails.Name);
        }
        else if (isImageFile(fileType))
        {
            await OpenLocalImageViewerMobile(args.FileDetails);
        }
    }

    private async Task OnMobileBeforeDownloadAsync(MfmDownloadEventArgs args)
    {
        try
        {
            var downloadNames = string.Join(",", args.Names);
            var downloadPath = args.Path;
            var url = $"{DownloadUrl}?downloadInput={System.Text.Json.JsonSerializer.Serialize(new { action = "download", path = downloadPath, names = args.Names, data = args.Files })}";
            await JSRuntime.InvokeVoidAsync("open", url, "_blank");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error downloading files for mobile");
            nm.sendMessage("Error", "Error downloading files", NotificationTypes.Error);
        }
    }

    private async Task OnMobileUploadToTelegramAsync(MfmUploadToTelegramEventArgs args)
    {
        try
        {
            MainLayout.OpenUploadToTelegramModal(id, args.Files.ToList());
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error opening upload to telegram dialog");
            nm.sendMessage("Error", "Error opening upload dialog", NotificationTypes.Error);
        }
    }

    private async Task OnMobileUploadToLocalAsync(MfmUploadToLocalEventArgs args)
    {
        try
        {
            ModalUpSer.id = id;
            ModalUpSer.url = "/api/file/Upload";
            ModalUpSer.filePath = args.Path;
            ModalUpSer.Open();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error opening upload to local dialog");
            nm.sendMessage("Error", "Error opening upload dialog", NotificationTypes.Error);
        }
    }

    private async Task OnMobileUrlMediaAsync(MfmUrlMediaEventArgs args)
    {
        try
        {
            if (args.File != null)
            {
                await ShowMediaURLModal(args.File.FilterPath, args.File.Name);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error showing media URL");
            nm.sendMessage("Error", "Error showing media URL", NotificationTypes.Error);
        }
    }

    private async Task OnMobileAddToPlaylistAsync(MfmAddToPlaylistEventArgs args)
    {
        try
        {
            if (args.IsMultiple && args.Files.Length > 0)
            {
                string localdir = MyNavigationManager.BaseUri + FileService.STATICRELATIVELOCALDIR.Replace("\\", "/");
                int addedCount = 0;
                foreach (var file in args.Files)
                {
                    string url = new System.Uri((Path.Combine(localdir, file.FilterPath.Substring(1).Replace("\\", "/"), file.Name)).Replace("\\", "/")).AbsoluteUri;
                    await JSRuntime.InvokeVoidAsync("addToAudioPlaylist", url, "audio/mpeg", file.Name);
                    addedCount++;
                }
                nm.sendMessage("Playlist", $"Added {addedCount} tracks to playlist", NotificationTypes.Success);
            }
            else if (args.File != null && IsAudioFile(args.File.Type?.ToLower() ?? ""))
            {
                string localdir = MyNavigationManager.BaseUri + FileService.STATICRELATIVELOCALDIR.Replace("\\", "/");
                string url = new System.Uri((Path.Combine(localdir, args.File.FilterPath.Substring(1).Replace("\\", "/"), args.File.Name)).Replace("\\", "/")).AbsoluteUri;
                await JSRuntime.InvokeVoidAsync("addToAudioPlaylist", url, null, args.File.Name);
                nm.sendMessage("Playlist", $"Added '{args.File.Name}' to playlist", NotificationTypes.Success);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error adding to playlist");
            nm.sendMessage("Error", "Error adding to playlist", NotificationTypes.Error);
        }
    }

    private async Task<FileManagerResponse<FileManagerDirectoryContent>?> CallFileOperationsAsync(
        string action,
        string path,
        FileManagerDirectoryContent[]? data,
        string? targetPath = null,
        FileManagerDirectoryContent? targetData = null,
        string? newName = null,
        string? searchString = null)
    {
        var requestData = new Dictionary<string, object?>
        {
            ["action"] = action,
            ["path"] = path,
            ["showHiddenItems"] = false,
            ["data"] = data ?? Array.Empty<FileManagerDirectoryContent>()
        };

        // Add names array for copy/move operations
        if (data != null && data.Length > 0)
        {
            requestData["names"] = data.Select(f => f.Name).ToArray();
        }

        if (targetPath != null)
        {
            requestData["targetPath"] = targetPath;
            requestData["targetData"] = targetData;
        }

        if (newName != null)
        {
            // For rename action: name = old name, newName = new name
            if (action == "rename" && data != null && data.Length > 0)
            {
                requestData["name"] = data[0].Name;  // Old name
                requestData["newName"] = newName;    // New name
            }
            else
            {
                // For create folder action: name = folder name
                requestData["name"] = newName;
            }
        }

        if (searchString != null)
        {
            requestData["searchString"] = searchString;
            requestData["caseSensitive"] = false;
        }

        var json = System.Text.Json.JsonSerializer.Serialize(requestData);
        var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");

        var response = await httpClient.PostAsync(FileOperationsUrl, content);

        if (response.IsSuccessStatusCode)
        {
            var responseJson = await response.Content.ReadAsStringAsync();
            return System.Text.Json.JsonSerializer.Deserialize<FileManagerResponse<FileManagerDirectoryContent>>(responseJson, new System.Text.Json.JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });
        }

        return null;
    }

    #endregion
}
