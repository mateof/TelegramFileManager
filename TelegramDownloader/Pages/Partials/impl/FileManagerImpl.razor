@using System.Web
@using Microsoft.AspNetCore.Mvc
@using Syncfusion.Blazor.Inputs
@using System.Net.Mime
@using TL
@using TelegramDownloader.Data
@using TelegramDownloader.Data.db
@using TelegramDownloader.Models
@using TelegramDownloader.Pages.Modals.InfoModals
@using TelegramDownloader.Pages.Modals
@using TelegramDownloader.Pages.Partials
@using TelegramDownloader.Services
@inject IFileService fs
@inject ITelegramService ts
@inject ILogger<FileManager> Logger
@inject IJSRuntime JSRuntime;
@inject NavigationManager MyNavigationManager;


<SfFileManager ID="remotefm" @ref="fm" TValue="FileManagerDirectoryContent" ShowThumbnail="false" SelectedItemsChanged="itemsChanged" AllowDragAndDrop="false" EnablePersistence="false" EnableVirtualization="@hasVirtualScroll">


    <FileManagerEvents TValue="FileManagerDirectoryContent"
    ToolbarItemClicked="toolBarClicked"
    ItemsMoving="ItemsMovingAsync"
    ItemRenaming="ItemRenamingAsync"
    Searching="SearchingAsync"
    OnFileOpen="fileOpen"
    FileSelection="FileSelectionAsync"
    FileSelected="FileSelectedAsync"
    OnRead="OnReadAsync"
    FolderCreating="FolderCreatingAsync"
    BeforeDownload="BeforeDownload"
    ItemsDeleting="ItemsDeletingAsync"
    ItemsUploaded="ItemsUploadedAsync"></FileManagerEvents>
    <FileManagerUploadSettings MaxFileSize="@(long.MaxValue)" AutoUpload="true"></FileManagerUploadSettings>
    <FileManagerToolbarSettings ToolbarItems="@Items"></FileManagerToolbarSettings>
    <FileManagerContextMenuSettings Visible="@(!isShared || isMyChannel)" File="@ContextItems"></FileManagerContextMenuSettings>
    <FileManagerSearchSettings FilterDelay="1200"></FileManagerSearchSettings>
    <FileManagerPageSettings PageSize="50" NumericItemsCount="5"></FileManagerPageSettings>
</SfFileManager>
<TelegramDownloader.Pages.Modals.DowloadFromTelegram @ref="Modal" isShare="@isShared" bsi="@bsi"></TelegramDownloader.Pages.Modals.DowloadFromTelegram>

<TelegramDownloader.Pages.Modals.InfoModals.MediaUrlModal @ref="mediaUrlModal"></TelegramDownloader.Pages.Modals.InfoModals.MediaUrlModal>
<TelegramDownloader.Pages.Modals.VideoPlayerModal @ref="videoPlayer"></TelegramDownloader.Pages.Modals.VideoPlayerModal>




@code {
    private Modals.DowloadFromTelegram Modal { get; set; }
    [Parameter]
    public string id { get; set; }
    [Parameter]
    public bool isShared { get; set; } = false;
    [Parameter]
    public BsonSharedInfoModel bsi { get; set; }
    public string chatName { get; set; }
    public static string[] selectedItems = new string[] { "" };
    public static bool downloadToServer = true;
    public static bool hasVirtualScroll { get; set; } = false;
    LocalFileManager lfm { get; set; }
    private VideoPlayerModal videoPlayer { get; set; } = default!;

    private MediaUrlModal mediaUrlModal { get; set; } = default!;

    public string[] ContextItems = new string[] { "Open", "Delete", "Download", "Rename", "Details"};
    private bool isMyChannel = false;

    SfFileManager<FileManagerDirectoryContent> fm { get; set; }
    NotificationModel nm = new NotificationModel();


    public List<ToolBarItemModel> Items = new List<ToolBarItemModel>(){
        new ToolBarItemModel() { Name = "Download" },
        new ToolBarItemModel() { Name = "SortBy" },
        new ToolBarItemModel() { Name = "Refresh" },
        new ToolBarItemModel() { Name = "DownloadServer", Text="Download To Local", TooltipText="Download To local", PrefixIcon="e-icons e-download" },
        new ToolBarItemModel() { Name = "Selection" },
        new ToolBarItemModel() { Name = "View" },
        new ToolBarItemModel() { Name = "Details" },
        new ToolBarItemModel() { Name = "UrlMedia", Text = "Url Media", TooltipText = "Url Media", PrefixIcon = "bi bi-collection-play-fill", Visible = false },
        new ToolBarItemModel() { Name = "Strm", Text = "Strm", TooltipText = "Strm folder", PrefixIcon = "bi bi-collection-play-fill", Visible = false }

    };

    // protected override async Task OnParametersSetAsync()
    // {
    //     await OnInitializedAsync();
    //     StateHasChanged();
    // }

    private void LoadFiles(InputFileChangeEventArgs e)
    {

    }


    protected override async Task OnInitializedAsync()
    {
        hasVirtualScroll = GeneralConfigStatic.config.hasFileManagerVirtualScroll;
        if (!isShared)
        {
            isMyChannel = ts.isMyChat(Convert.ToInt64(id));
            if (isMyChannel)
                // Items = Items.Prepend(new ToolBarItemModel() { Name = "NewFolder" }).ToList();
                Items.AddRange(new List<ToolBarItemModel>(){
                        new ToolBarItemModel() { Name = "NewFolder" },
                        new ToolBarItemModel() { Name = "Cut" },
                        new ToolBarItemModel() { Name = "Copy" },
                        new ToolBarItemModel() { Name = "Paste" },
                        new ToolBarItemModel() { Name = "Delete" },
                        new ToolBarItemModel() { Name = "Upload" },
                        new ToolBarItemModel() { Name = "Rename" },
                        new ToolBarItemModel() { Name = "ShowApp", Text="Show in APP", TooltipText="Show in Telegram APP", PrefixIcon="bi bi-telegram" },
                        new ToolBarItemModel() { Name = "Share", Text="Share File", TooltipText="Share file or folder", PrefixIcon="bi bi-share" }
                    }
                );
            else
                Items.AddRange(new List<ToolBarItemModel>(){
                        new ToolBarItemModel() { Name = "NewFolder" },
                        new ToolBarItemModel() { Name = "Cut" },
                        new ToolBarItemModel() { Name = "Copy" },
                        new ToolBarItemModel() { Name = "Paste" },
                        new ToolBarItemModel() { Name = "Delete" },
                        new ToolBarItemModel() { Name = "Rename" },
                        new ToolBarItemModel() { Name = "ShowApp", Text="Show in APP", TooltipText="Show in Telegram APP", PrefixIcon="bi bi-telegram" },
                        new ToolBarItemModel() { Name = "Share", Text="Share File", TooltipText="Share file or folder", PrefixIcon="bi bi-share" }
                    }
                );
            try
            {
                await fs.CreateDatabase(id);
                chatName = ts.getChatName(Convert.ToInt64(id));
            }
            catch (Exception e)
            {
                Logger.LogError(e, "Error on CreateDatabase");
                nm.sendMessage("Error", "Error on CreateDatabase", NotificationTypes.Error);
            }
        } else
        {
            ContextItems = new string[] { "Details" };
        }

    }

    public async Task ItemRenamingAsync(ItemRenameEventArgs<FileManagerDirectoryContent> args)
    {
        args.Response = await fs.RenameFileOrFolder(id, args.File, args.NewName);
        // args.Response = await FileManagerService.Rename(args.Path, args.File.Name, args.NewName, false, args.ShowFileExtension, args.File);
    }

    public async Task fileOpen(FileOpenEventArgs<FileManagerDirectoryContent> args)
    {
        if (args.FileDetails == null || !args.FileDetails.IsFile)
            return;
        if (args != null && args.FileDetails != null && args.FileDetails.IsFile && isAudioFile(args.FileDetails.Type.ToLower()))
        {
            await playAudio(args);
            return;
        }

        if (args != null && args.FileDetails != null && args.FileDetails.IsFile && isVideoFile(args.FileDetails.Type.ToLower()))
        {
            videoPlayer.ShowModal(await getMediaUrl(args.FileDetails.Id, args.FileDetails.Name, args.FileDetails.Size));
            return;
        }

        string filePath = getTempFileMediaUrl(args.FileDetails.Id, args.FileDetails.Name);

        await JSRuntime.InvokeVoidAsync("open", filePath, "_blank");
    }

    private bool isVideoFile(string fileExtension)
    {
        return new List<string> { ".mov", ".mp4", ".m4v", ".ogv", ".webm", ".flv", ".f4v" }.Contains(fileExtension);
    }

    private bool isAudioFile(string fileExtension)
    {
        return new List<string> { ".mp3", ".ogg", ".flac", ".aac", ".wav" }.Contains(fileExtension);
    }

    private async Task playAudio(FileOpenEventArgs<FileManagerDirectoryContent> args)
    {
        await JSRuntime.InvokeVoidAsync("openAudioPlayerModal", await getMediaUrl(args.FileDetails.Id, args.FileDetails.Name, args.FileDetails.Size), null, args.FileDetails.Name);
    }

    public async Task SearchingAsync(SearchEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            args.Response = isShared ? await fs.SearchAsync(DbService.SHARED_DB_NAME, args.Path, args.SearchText, bsi.CollectionId) : await fs.SearchAsync(id, args.Path, args.SearchText);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on SearchingAsync");
            nm.sendMessage("Error", "Error on SearchingAsync", NotificationTypes.Error);
        }

    }

    public async Task ItemsDeletingAsync(ItemsDeleteEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            args.Response = await fs.itemDeleteAsync(id, args);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on itemDeleteAsync");
            nm.sendMessage("Error", "Error on ItemsDeletingAsync", NotificationTypes.Error);
        }

    }

    public async Task ItemsMovingAsync(ItemsMoveEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            args.Response = await fs.CopyItems(id, args);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on move item");
            nm.sendMessage("Error", "Error on ItemsMovingAsync", NotificationTypes.Error);
            args.Response = new FileManagerResponse<FileManagerDirectoryContent>();
        }

    }

    public void onCustomClick(ClickEventArgs args)
    {
        Console.WriteLine("");
    }

    private async Task ShowMediaURLModal(string idFile, String name, long size, bool forcePreDownload = false)
    {
        mediaUrlModal.url = await getMediaUrl(idFile, name, size, forcePreDownload);
        await mediaUrlModal.OnShowModalClick();
    }

    private async Task<string> getMediaUrl(string idFile, String name, long size, bool forcePreDownload = false)
    {
        BsonFileManagerModel item = null;
        if (isShared)
            item = await fs.getSharedItemById(id: idFile, collection: id);
        else
            item = await fs.getItemById(id, idFile);
        string localdir = MyNavigationManager.BaseUri;
        if (forcePreDownload || (HelperService.bytesToMegaBytes(size) <= GeneralConfigStatic.config.MaxPreloadFileSizeInMb && item.MessageId != null))
        {
            return new System.Uri(Path.Combine(localdir, "api/file/GetFile", name).Replace("\\", "/") + $"?idChannel={(isShared ? bsi.ChannelId : id)}&idFile={item.MessageId}").AbsoluteUri;
        }
        return new System.Uri(Path.Combine(localdir, "api/file/GetFileStream", isShared ? bsi.ChannelId : id, idFile, name).Replace("\\", "/")).AbsoluteUri;
    }

    private string getTempFileMediaUrl(string idFile, String name)
    {
        string localdir = MyNavigationManager.BaseUri;
        return new System.Uri(Path.Combine(localdir, "api/file/GetFileByTfmId", name).Replace("\\", "/") + $"?idChannel={(isShared ? bsi.ChannelId : id)}&idFile={idFile}").AbsoluteUri;
    }

    public async Task toolBarClicked(ToolbarClickEventArgs<FileManagerDirectoryContent> args)
    {
        if (args.Item.Text == "Download To Local")
        {
            Modal.id = id;
            Modal.filePath = args.FileDetails.FirstOrDefault().IsFile ? args.FileDetails.FirstOrDefault().FilterPath.Replace("\\", "/") : args.FileDetails.FirstOrDefault().FilterPath.Replace("\\", "/") + args.FileDetails.FirstOrDefault().Name + "/";
            Modal.fileList = args.FileDetails;
            Modal.Open();
        }
        if (args.Item.Text == "Show in APP")
        {
            var item = await fs.getItemById(id, args.FileDetails.FirstOrDefault().Id);
            if (item.IsFile)
                await JSRuntime.InvokeVoidAsync("open", $"tg://privatepost?channel={id}&post={item.MessageId ?? item.ListMessageId.FirstOrDefault()}", "_blank");
        }
        if (args.Item.Text == "Share File")
        {
            MyNavigationManager.NavigateTo("/api/file/share/" + id + $"?bsonId={args.FileDetails.FirstOrDefault().Id}&fileName={args.FileDetails.FirstOrDefault().Name}", true);
        }
        if (args.Item.Text == "Url Media" && args.FileDetails.Count() > 0)
        {
            await ShowMediaURLModal(args.FileDetails[0].Id, args.FileDetails[0].Name, args.FileDetails[0].Size, !(isAudioFile(args.FileDetails[0].Type.ToLower()) || isVideoFile(args.FileDetails[0].Type.ToLower())));
        }
        if (args.Item.Text == "Strm" && args.FileDetails.Count() > 0)
        {
            var file = args.FileDetails.FirstOrDefault();
            MyNavigationManager.NavigateTo($"/api/file/strm?idChannel={id}&path={file.FilterPath + file.Name + "/"}&host={MyNavigationManager.BaseUri}", true);
            // await JSRuntime.InvokeVoidAsync("open", $"{MyNavigationManager.BaseUri}?idChannel={id}&path={args.FileDetails.FirstOrDefault().FilterPath}&host={MyNavigationManager.BaseUri}", "_blank");
        }
        Console.WriteLine("");
    }

    public async Task itemsChanged(string[] items)
    {
        List<string> showInOne = new List<string>() { "ShowApp", "Share" };
        if (items.Count() > 1)
        {
            Items.Where(x => showInOne.Contains(x.Name)).ToList().ForEach(x => x.Visible = false);
        }
        else
        {
            Items.Where(x => showInOne.Contains(x.Name)).ToList().ForEach(x => x.Visible = true);
        }
        Console.WriteLine("");
    }

    public async Task FileSelectionAsync(FileSelectionEventArgs<FileManagerDirectoryContent> args)
    {
        List<FileManagerDirectoryContent> selectedList = fm.GetSelectedFiles();
        if ((selectedList.Count() + (args.Action == "UnSelect" ? -1 : selectedList.Count() == 0 ? 1 : 0)) == 1)
        {
            if (args.FileDetails.IsFile)
            {
                Items.Where(x => x.Name == "Strm").FirstOrDefault().Visible = false;
                Items.Where(x => x.Name == "UrlMedia").FirstOrDefault().Visible = true;
                return;
            } else
            {
                Items.Where(x => x.Name == "UrlMedia").FirstOrDefault().Visible = false;
                Items.Where(x => x.Name == "Strm").FirstOrDefault().Visible = true;
                return;
            }

        }
        Items.Where(x => x.Name == "UrlMedia").FirstOrDefault().Visible = false;
        Items.Where(x => x.Name == "Strm").FirstOrDefault().Visible = false;

    }

    public async Task FileSelectedAsync(FileSelectEventArgs<FileManagerDirectoryContent> args)
    {

        Console.WriteLine("");
    }

    public async Task<string> ItemsUploadedAsync(ItemsUploadedEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            foreach (UploadFiles file in args.Files)
                await fs.UploadFile(id, args.Path, file);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on ItemsUploadedAsync items");
            nm.sendMessage("Error", "Error on ItemsUploadedAsync", NotificationTypes.Error);
        }

        return "";
    }

    public async Task BeforeDownload(BeforeDownloadEventArgs<FileManagerDirectoryContent> args)
    {
        // foreach (string name in args.DownloadData.Names)
        // {

        // }
        try
        {
            if (downloadToServer)
            {
                if (isShared)
                    await fs.downloadFile(DbService.SHARED_DB_NAME, args.DownloadData.Path, args.DownloadData.Names.ToList(), null, bsi.CollectionId);
                else
                    await fs.downloadFile(id, args.DownloadData.Path, args.DownloadData.Names.ToList(), null);
            }
            else
            {
                MemoryStream ms = new MemoryStream();
                ms = isShared ? await fs.getImage(DbService.SHARED_DB_NAME, args.DownloadData.Path, args.DownloadData.Names[0], ms, bsi.CollectionId) : await fs.getImage(id, args.DownloadData.Path, args.DownloadData.Names[0], ms);
                ms.Position = 0;
                args.FileStream = ms;
                args.DownloadFileName = args.DownloadData.Names[0];
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on BeforeDownload");
            nm.sendMessage("Error", "Error on BeforeDownload", NotificationTypes.Error);
        }


    }

    public async Task FolderCreatingAsync(FolderCreateEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            FileManagerResponse<FileManagerDirectoryContent> response = new FileManagerResponse<FileManagerDirectoryContent>();
            response.Files = await fs.createFolder(id, args); // await FileManagerService.Create(args.Path, args.FolderName, args.ParentFolder);
            await Task.Yield();
            args.Response = response;
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on FolderCreatingAsync");
            nm.sendMessage("Error", "Error on FolderCreatingAsync", NotificationTypes.Error);
        }

    }

    public async Task BeforeImageLoadAsync(BeforeImageLoadEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            using HttpClient Http = new HttpClient();
            var str = await Http.GetStreamAsync($"https://localhost:7205/api/file/GetImage?path={HttpUtility.UrlEncode(args.ImageUrl)}");
            args.FileStream = str;
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on BeforeImageLoadAsync");
            nm.sendMessage("Error", "Error on BeforeImageLoadAsync", NotificationTypes.Error);
        }

        // var i = 1;
        // var result = await FileManagerService.GetImage(args.ImageUrl, false, args.FileDetails);
        // result.FileStream.Position = 0;
        // MemoryStream ms = new MemoryStream();
        // await fs.getImage(args.ImageUrl, ms);


        //     // var result = Task.Run(async () => await fs.getImage(args.ImageUrl, ms));
        //     // result.Wait();
        //     // ms.CopyTo(file);
        // args.FileStream = ms;


    }

    private async Task OnReadAsync(ReadEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            string path = args.Path;
            List<FileManagerDirectoryContent> fileDetails = args.Folder;

            args.Response = isShared ? await fs.GetFilesPath(DbService.SHARED_DB_NAME, path, fileDetails, bsi.CollectionId) : await fs.GetFilesPath(id, path, fileDetails);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnReadAsync");
            nm.sendMessage("Error", "Error on OnReadAsync", NotificationTypes.Error);
        }

    }

    private void doToolbarItemInvisible(String name)
    {
        Items.Where(x => name.Equals(x.Name)).ToList().ForEach(x => x.Visible = false);
    }
}
