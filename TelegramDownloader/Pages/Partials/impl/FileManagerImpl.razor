@using System.Web
@using Microsoft.AspNetCore.Mvc
@using Syncfusion.Blazor.Inputs
@using System.Net.Mime
@using TL
@using TelegramDownloader.Data
@using TelegramDownloader.Data.db
@using TelegramDownloader.Models
@using TelegramDownloader.Pages.Modals.InfoModals
@using TelegramDownloader.Pages.Modals
@using TelegramDownloader.Pages.Partials
@using TelegramDownloader.Services
@using TelegramDownloader.Shared.MobileFileManager
@using TelegramDownloader.Shared
@inject IFileService fs
@inject ITelegramService ts
@inject ILogger<FileManager> Logger
@inject IJSRuntime JSRuntime;
@inject NavigationManager MyNavigationManager;

@* Loading while detecting viewport *@
@if (!_viewportDetected)
{
    <div style="display: flex; justify-content: center; align-items: center; height: 200px;">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}

@* Desktop FileManager - only render when viewport detected and not on mobile *@
@if (_viewportDetected && !_isMobileView)
{
    <SfFileManager ID="remotefm" @ref="fm" TValue="FileManagerDirectoryContent"
        ShowThumbnail="false"
        SelectedItemsChanged="itemsChanged"
        AllowDragAndDrop="false"
        EnablePersistence="false"
        EnableVirtualization="@hasVirtualScroll">


        <FileManagerEvents TValue="FileManagerDirectoryContent"
        ToolbarItemClicked="toolBarClicked"
        ItemsMoving="ItemsMovingAsync"
        ItemRenaming="ItemRenamingAsync"
        Searching="SearchingAsync"
        OnFileOpen="fileOpen"
        FileSelection="FileSelectionAsync"
        FileSelected="FileSelectedAsync"
        OnRead="OnReadAsync"
        FolderCreating="FolderCreatingAsync"
        BeforeDownload="BeforeDownload"
        ItemsDeleting="ItemsDeletingAsync"
        ItemsUploaded="ItemsUploadedAsync"
        OnMenuClick="OnMenuClickAsync"></FileManagerEvents>
        <FileManagerUploadSettings MaxFileSize="@(long.MaxValue)" AutoUpload="true"></FileManagerUploadSettings>
        <FileManagerToolbarSettings ToolbarItems="@Items"></FileManagerToolbarSettings>
        <FileManagerContextMenuSettings Visible="@(!isShared || isMyChannel)" File="@ContextItems"></FileManagerContextMenuSettings>
        <FileManagerSearchSettings FilterDelay="1200"></FileManagerSearchSettings>
        <FileManagerPageSettings PageSize="50" NumericItemsCount="5"></FileManagerPageSettings>
    </SfFileManager>
}

@* Mobile FileManager *@
@if (_viewportDetected && _isMobileView)
{
    <div class="mobile-fm-container">
        <MobileFileManager @ref="mobileFileManager"
            Id="@id"
            IsShared="@isShared"
            RootFolderName="Files"
            CanCopy="@(!isShared || isMyChannel)"
            CanCut="@(!isShared || isMyChannel)"
            CanDelete="@(!isShared || isMyChannel)"
            CanRename="@(!isShared || isMyChannel)"
            CanCreate="@(!isShared || isMyChannel)"
            CanUpload="false"
            CanDownloadToLocal="true"
            CanShareFile="@(isMyChannel && !isShared)"
            CanShowInApp="true"
            CanShowUrlMedia="true"
            CanStrm="true"
            CanPreload="@(!isShared)"
            OnRead="OnMobileReadAsync"
            OnItemsDeleting="OnMobileItemsDeletingAsync"
            OnItemsMoving="OnMobileItemsMovingAsync"
            OnItemRenaming="OnMobileItemRenamingAsync"
            OnFolderCreating="OnMobileFolderCreatingAsync"
            OnSearching="OnMobileSearchingAsync"
            OnFileOpen="OnMobileFileOpenAsync"
            OnBeforeDownload="OnMobileBeforeDownloadAsync"
            OnDownloadToLocal="OnMobileDownloadToLocalAsync"
            OnShareFile="OnMobileShareFileAsync"
            OnShowInApp="OnMobileShowInAppAsync"
            OnUrlMedia="OnMobileUrlMediaAsync"
            OnStrm="OnMobileStrmAsync"
            OnPreloadFiles="OnMobilePreloadFilesAsync"
            CanAddToPlaylist="true"
            OnAddToPlaylist="OnMobileAddToPlaylistAsync"
            CanSaveToPlaylist="true"
            OnSaveToPlaylist="OnMobileSaveToPlaylistAsync"
            OnPathChanged="OnMobilePathChanged" />
    </div>
}

<TelegramDownloader.Pages.Modals.DowloadFromTelegram @ref="Modal" isShare="@isShared" bsi="@bsi"></TelegramDownloader.Pages.Modals.DowloadFromTelegram>

<TelegramDownloader.Pages.Modals.InfoModals.MediaUrlModal @ref="mediaUrlModal"></TelegramDownloader.Pages.Modals.InfoModals.MediaUrlModal>
<TelegramDownloader.Pages.Modals.VideoPlayerModal @ref="videoPlayer"></TelegramDownloader.Pages.Modals.VideoPlayerModal>
<TelegramDownloader.Pages.Modals.PdfViewerModal @ref="pdfViewer"></TelegramDownloader.Pages.Modals.PdfViewerModal>
<TelegramDownloader.Pages.Modals.ImageViewerModal @ref="imageViewer"></TelegramDownloader.Pages.Modals.ImageViewerModal>
<TelegramDownloader.Pages.Modals.ExportStrmModal @ref="exportStrmModal" OnExportCompleted="OnStrmExportCompleted"></TelegramDownloader.Pages.Modals.ExportStrmModal>




@code {
#nullable disable
#pragma warning disable BL0005 // Setting component parameters from code for modal pattern
    private Modals.DowloadFromTelegram Modal { get; set; }
    [Parameter]
    public string id { get; set; }
    [Parameter]
    public bool isShared { get; set; } = false;
    [Parameter]
    public BsonSharedInfoModel bsi { get; set; }
    public string chatName { get; set; }
    public static string[] selectedItems = new string[] { "" };
    public static bool downloadToServer = true;
    public static bool hasVirtualScroll { get; set; } = false;
    LocalFileManager lfm { get; set; }
    private VideoPlayerModal videoPlayer { get; set; } = default!;
    private PdfViewerModal pdfViewer { get; set; } = default!;
    private ImageViewerModal imageViewer { get; set; } = default!;

    private MediaUrlModal mediaUrlModal { get; set; } = default!;
    private ExportStrmModal exportStrmModal { get; set; } = default!;

    public string[] ContextItems = new string[] { "Open", "Delete", "Download", "Rename", "Details", "Add to Playlist"};
    private bool isMyChannel = false;

    SfFileManager<FileManagerDirectoryContent> fm { get; set; }
    MobileFileManager mobileFileManager { get; set; }
    NotificationModel nm = new NotificationModel();

    // Mobile detection
    private bool _isMobileView = false;
    private bool _viewportDetected = false; // Don't render until viewport is detected
    private const int MobileBreakpoint = 1920; // Custom breakpoint for mobile file manager


    public List<ToolBarItemModel> Items = new List<ToolBarItemModel>(){
        new ToolBarItemModel() { Name = "Download" },
        new ToolBarItemModel() { Name = "SortBy" },
        new ToolBarItemModel() { Name = "Refresh" },
        new ToolBarItemModel() { Name = "DownloadServer", Text="Download To Local", TooltipText="Download To local", PrefixIcon="e-icons e-download" },
        new ToolBarItemModel() { Name = "Preload", Text="Preload", TooltipText="Preload files to cache", PrefixIcon="e-icons e-download" },
        new ToolBarItemModel() { Name = "Selection" },
        new ToolBarItemModel() { Name = "View" },
        new ToolBarItemModel() { Name = "Details" },
        new ToolBarItemModel() { Name = "UrlMedia", Text = "Url Media", TooltipText = "Url Media", PrefixIcon = "bi bi-collection-play-fill", Visible = false },
        new ToolBarItemModel() { Name = "Strm", Text = "Strm", TooltipText = "Strm folder", PrefixIcon = "bi bi-collection-play-fill", Visible = false },
        new ToolBarItemModel() { Name = "Playlists", Text = "Playlists", TooltipText = "Manage Playlists", PrefixIcon = "bi bi-music-note-list" }

    };

    private string _previousId;
    private string _previousBsiId;
    private bool _firstRenderComplete = false;
    private bool _needsRefresh = false;

    protected override async Task OnParametersSetAsync()
    {
        string currentBsiId = bsi?.Id;
        bool idChanged = _previousId != id;
        bool bsiChanged = isShared && _previousBsiId != currentBsiId && currentBsiId != null;

        if (idChanged || bsiChanged)
        {
            _previousId = id;
            _previousBsiId = currentBsiId;
            await LoadDataAsync();

            // Solo marcar refresh si ya pas√≥ el primer render
            if (_firstRenderComplete)
            {
                _needsRefresh = true;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _firstRenderComplete = true;
            // Detect viewport size on first render
            await DetectMobileView();
        }

        if (_needsRefresh && fm != null)
        {
            _needsRefresh = false;
            fm.Path = "/";
            await fm.RefreshFilesAsync();
        }
    }

    private async Task DetectMobileView()
    {
        try
        {
            // Check if config forces mobile file manager
            if (GeneralConfigStatic.config.UseMobileFileManagerAlways)
            {
                _isMobileView = true;
            }
            else
            {
                var width = await JSRuntime.InvokeAsync<int>("eval", "window.innerWidth");
                _isMobileView = width < MobileBreakpoint;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error detecting viewport size");
            _isMobileView = false;
        }
        finally
        {
            _viewportDetected = true;
            StateHasChanged();

            // After viewport is detected, navigate to path from URL if present
            await NavigateToPathFromUrl();
        }
    }

    private async Task NavigateToPathFromUrl()
    {
        try
        {
            var uri = new Uri(MyNavigationManager.Uri);
            var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
            var pathFromUrl = query["path"];

            if (!string.IsNullOrEmpty(pathFromUrl) && mobileFileManager != null)
            {
                // Decode the path and ensure it ends with /
                var decodedPath = Uri.UnescapeDataString(pathFromUrl);
                if (!decodedPath.EndsWith("/"))
                    decodedPath += "/";

                await mobileFileManager.NavigateToPathSilent(decodedPath);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error navigating to path from URL");
        }
    }

    private void OnMobilePathChanged(string path)
    {
        try
        {
            // Update URL without triggering navigation
            var baseUri = MyNavigationManager.Uri.Split('?')[0];
            var newUrl = path == "/" ? baseUri : $"{baseUri}?path={Uri.EscapeDataString(path)}";
            MyNavigationManager.NavigateTo(newUrl, forceLoad: false, replace: true);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating URL with path");
        }
    }

    public async Task RefreshFileManager()
    {
        if (fm != null)
        {
            fm.Path = "/";
            await fm.RefreshFilesAsync();
        }
        if (mobileFileManager != null)
        {
            mobileFileManager.Path = "/";
            await mobileFileManager.RefreshFilesAsync();
        }
    }

    private void LoadFiles(InputFileChangeEventArgs e)
    {

    }


    private async Task LoadDataAsync()
    {
        hasVirtualScroll = GeneralConfigStatic.config.hasFileManagerVirtualScroll;
        if (!isShared)
        {
            isMyChannel = ts.isMyChat(Convert.ToInt64(id));

            // Reset Items to base items
            Items = new List<ToolBarItemModel>(){
                new ToolBarItemModel() { Name = "Download" },
                new ToolBarItemModel() { Name = "SortBy" },
                new ToolBarItemModel() { Name = "Refresh" },
                new ToolBarItemModel() { Name = "DownloadServer", Text="Download To Local", TooltipText="Download To local", PrefixIcon="e-icons e-download" },
                new ToolBarItemModel() { Name = "Preload", Text="Preload", TooltipText="Preload files to cache", PrefixIcon="e-icons e-download" },
                new ToolBarItemModel() { Name = "Selection" },
                new ToolBarItemModel() { Name = "View" },
                new ToolBarItemModel() { Name = "Details" },
                new ToolBarItemModel() { Name = "UrlMedia", Text = "Url Media", TooltipText = "Url Media", PrefixIcon = "bi bi-collection-play-fill", Visible = false },
                new ToolBarItemModel() { Name = "Strm", Text = "Strm", TooltipText = "Strm folder", PrefixIcon = "bi bi-collection-play-fill", Visible = false },
                new ToolBarItemModel() { Name = "Playlists", Text = "Playlists", TooltipText = "Manage Playlists", PrefixIcon = "bi bi-music-note-list" }
            };

            if (isMyChannel)
                Items.AddRange(new List<ToolBarItemModel>(){
                        new ToolBarItemModel() { Name = "NewFolder" },
                        new ToolBarItemModel() { Name = "Cut" },
                        new ToolBarItemModel() { Name = "Copy" },
                        new ToolBarItemModel() { Name = "Paste" },
                        new ToolBarItemModel() { Name = "Delete" },
                        new ToolBarItemModel() { Name = "Upload" },
                        new ToolBarItemModel() { Name = "Rename" },
                        new ToolBarItemModel() { Name = "ShowApp", Text="Show in APP", TooltipText="Show in Telegram APP", PrefixIcon="bi bi-telegram" },
                        new ToolBarItemModel() { Name = "Share", Text="Share File", TooltipText="Share file or folder", PrefixIcon="bi bi-share" }
                    }
                );
            else
                Items.AddRange(new List<ToolBarItemModel>(){
                        new ToolBarItemModel() { Name = "NewFolder" },
                        new ToolBarItemModel() { Name = "Cut" },
                        new ToolBarItemModel() { Name = "Copy" },
                        new ToolBarItemModel() { Name = "Paste" },
                        new ToolBarItemModel() { Name = "Delete" },
                        new ToolBarItemModel() { Name = "Rename" },
                        new ToolBarItemModel() { Name = "ShowApp", Text="Show in APP", TooltipText="Show in Telegram APP", PrefixIcon="bi bi-telegram" },
                        new ToolBarItemModel() { Name = "Share", Text="Share File", TooltipText="Share file or folder", PrefixIcon="bi bi-share" }
                    }
                );
            try
            {
                await fs.CreateDatabase(id);
                chatName = ts.getChatName(Convert.ToInt64(id));
            }
            catch (Exception e)
            {
                Logger.LogError(e, "Error on CreateDatabase");
                nm.sendMessage("Error", "Error on CreateDatabase", NotificationTypes.Error);
            }
        } else
        {
            ContextItems = new string[] { "Details" };
        }

    }

    #region Desktop FileManager Events

    public async Task ItemRenamingAsync(ItemRenameEventArgs<FileManagerDirectoryContent> args)
    {
        args.Response = await fs.RenameFileOrFolder(id, args.File, args.NewName);
    }

    public async Task fileOpen(FileOpenEventArgs<FileManagerDirectoryContent> args)
    {
        if (args.FileDetails == null || !args.FileDetails.IsFile)
            return;
        args.Cancel = true;
        if (args != null && args.FileDetails != null && args.FileDetails.IsFile && isAudioFile(args.FileDetails.Type.ToLower()))
        {
            await playAudio(args.FileDetails);
            return;
        }

        if (args != null && args.FileDetails != null && args.FileDetails.IsFile && isVideoFile(args.FileDetails.Type.ToLower()))
        {
            videoPlayer.ShowModal(await getVideoUrl(args.FileDetails.Id, args.FileDetails.Name, args.FileDetails.Size), args.FileDetails.Name);
            return;
        }

        if (args != null && args.FileDetails != null && args.FileDetails.IsFile && isPdfFile(args.FileDetails.Type.ToLower()))
        {
            var pdfUrl = await getPdfViewUrl(args.FileDetails.Id, args.FileDetails.Name, args.FileDetails.Size);
            await pdfViewer.ShowModal(pdfUrl, args.FileDetails.Name);
            return;
        }

        if (args != null && args.FileDetails != null && args.FileDetails.IsFile && isImageFile(args.FileDetails.Type.ToLower()))
        {
            await OpenImageViewer(args.FileDetails);
            return;
        }

        string filePath = getTempFileMediaUrl(args.FileDetails.Id, args.FileDetails.Name);

        await JSRuntime.InvokeVoidAsync("open", filePath, "_blank");
    }

    public async Task SearchingAsync(SearchEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            args.Response = isShared ? await fs.SearchAsync(DbService.SHARED_DB_NAME, args.Path, args.SearchText, bsi.CollectionId) : await fs.SearchAsync(id, args.Path, args.SearchText);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on SearchingAsync");
            nm.sendMessage("Error", "Error on SearchingAsync", NotificationTypes.Error);
        }

    }

    public async Task ItemsDeletingAsync(ItemsDeleteEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            args.Response = await fs.itemDeleteAsync(id, args);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on itemDeleteAsync");
            nm.sendMessage("Error", "Error on ItemsDeletingAsync", NotificationTypes.Error);
        }

    }

    public async Task ItemsMovingAsync(ItemsMoveEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            args.Response = await fs.CopyItems(id, args);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on move item");
            nm.sendMessage("Error", "Error on ItemsMovingAsync", NotificationTypes.Error);
            args.Response = new FileManagerResponse<FileManagerDirectoryContent>();
        }

    }

    public void onCustomClick(ClickEventArgs args)
    {
        Console.WriteLine("");
    }

    public async Task toolBarClicked(ToolbarClickEventArgs<FileManagerDirectoryContent> args)
    {
        if (args.Item.Text == "Download To Local")
        {
            Modal.id = id;
            Modal.filePath = args.FileDetails.FirstOrDefault().IsFile ? args.FileDetails.FirstOrDefault().FilterPath.Replace("\\", "/") : args.FileDetails.FirstOrDefault().FilterPath.Replace("\\", "/") + args.FileDetails.FirstOrDefault().Name + "/";
            Modal.fileList = args.FileDetails;
            Modal.Open();
        }
        if (args.Item.Text == "Show in APP")
        {
            var item = await fs.getItemById(id, args.FileDetails.FirstOrDefault().Id);
            if (item.IsFile)
                await JSRuntime.InvokeVoidAsync("open", $"tg://privatepost?channel={id}&post={item.MessageId ?? item.ListMessageId.FirstOrDefault()}", "_blank");
        }
        if (args.Item.Text == "Share File")
        {
            MyNavigationManager.NavigateTo("/api/file/share/" + id + $"?bsonId={args.FileDetails.FirstOrDefault().Id}&fileName={args.FileDetails.FirstOrDefault().Name}", true);
        }
        if (args.Item.Text == "Url Media" && args.FileDetails.Count() > 0)
        {
            await ShowMediaURLModal(args.FileDetails[0].Id, args.FileDetails[0].Name, args.FileDetails[0].Size, !(isAudioFile(args.FileDetails[0].Type.ToLower()) || isVideoFile(args.FileDetails[0].Type.ToLower())));
        }
        if (args.Item.Text == "Strm" && args.FileDetails.Count() > 0)
        {
            var file = args.FileDetails.FirstOrDefault();
            exportStrmModal.Open(id, file.FilterPath + file.Name + "/", MyNavigationManager.BaseUri);
        }
        if (args.Item.Text == "Preload" && args.FileDetails.Count() > 0)
        {
            nm.sendMessage("Preload", $"Starting preload of {args.FileDetails.Count()} items to cache...", NotificationTypes.Info);
            var channelId = isShared ? bsi.ChannelId : id;
            _ = Task.Run(async () =>
            {
                var count = await fs.PreloadFilesToTemp(channelId, args.FileDetails.ToList());
                nm.sendMessage("Preload Complete", $"Preloaded {count} files to cache", NotificationTypes.Success);
            });
        }
        if (args.Item.Text == "Playlists")
        {
            MainLayout.OpenPlaylistManager();
        }
        Console.WriteLine("");
    }

    public async Task itemsChanged(string[] items)
    {
        List<string> showInOne = new List<string>() { "ShowApp", "Share" };
        if (items.Count() > 1)
        {
            Items.Where(x => showInOne.Contains(x.Name)).ToList().ForEach(x => x.Visible = false);
        }
        else
        {
            Items.Where(x => showInOne.Contains(x.Name)).ToList().ForEach(x => x.Visible = true);
        }
        Console.WriteLine("");
    }

    public async Task FileSelectionAsync(FileSelectionEventArgs<FileManagerDirectoryContent> args)
    {
        List<FileManagerDirectoryContent> selectedList = fm.GetSelectedFiles();
        if ((selectedList.Count() + (args.Action == "UnSelect" ? -1 : selectedList.Count() == 0 ? 1 : 0)) == 1)
        {
            if (args.FileDetails.IsFile)
            {
                Items.Where(x => x.Name == "Strm").FirstOrDefault().Visible = false;
                Items.Where(x => x.Name == "UrlMedia").FirstOrDefault().Visible = true;
                return;
            } else
            {
                Items.Where(x => x.Name == "UrlMedia").FirstOrDefault().Visible = false;
                Items.Where(x => x.Name == "Strm").FirstOrDefault().Visible = true;
                return;
            }

        }
        Items.Where(x => x.Name == "UrlMedia").FirstOrDefault().Visible = false;
        Items.Where(x => x.Name == "Strm").FirstOrDefault().Visible = false;

    }

    public async Task FileSelectedAsync(FileSelectEventArgs<FileManagerDirectoryContent> args)
    {

        Console.WriteLine("");
    }

    public async Task OnMenuClickAsync(MenuClickEventArgs<FileManagerDirectoryContent> args)
    {
        if (args.Item.Text == "Add to Playlist" && args.FileDetails.Count() == 1)
        {
            var file = args.FileDetails.First();
            if (file.IsFile && isAudioFile(file.Type?.ToLower() ?? ""))
            {
                var url = await getMediaUrl(file.Id, file.Name, file.Size);
                await JSRuntime.InvokeVoidAsync("addToAudioPlaylist", url, null, file.Name);
                nm.sendMessage("Playlist", $"Added '{file.Name}' to playlist", NotificationTypes.Success);
            }
        }
    }

    public async Task<string> ItemsUploadedAsync(ItemsUploadedEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            foreach (UploadFiles file in args.Files)
                await fs.UploadFile(id, args.Path, file);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on ItemsUploadedAsync items");
            nm.sendMessage("Error", "Error on ItemsUploadedAsync", NotificationTypes.Error);
        }

        return "";
    }

    public async Task BeforeDownload(BeforeDownloadEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            if (downloadToServer)
            {
                if (isShared)
                    await fs.downloadFile(DbService.SHARED_DB_NAME, args.DownloadData.Path, args.DownloadData.Names.ToList(), null, bsi.CollectionId);
                else
                    await fs.downloadFile(id, args.DownloadData.Path, args.DownloadData.Names.ToList(), null);
            }
            else
            {
                MemoryStream ms = new MemoryStream();
                ms = isShared ? await fs.getImage(DbService.SHARED_DB_NAME, args.DownloadData.Path, args.DownloadData.Names[0], ms, bsi.CollectionId) : await fs.getImage(id, args.DownloadData.Path, args.DownloadData.Names[0], ms);
                ms.Position = 0;
                args.FileStream = ms;
                args.DownloadFileName = args.DownloadData.Names[0];
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on BeforeDownload");
            nm.sendMessage("Error", "Error on BeforeDownload", NotificationTypes.Error);
        }


    }

    public async Task FolderCreatingAsync(FolderCreateEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            FileManagerResponse<FileManagerDirectoryContent> response = new FileManagerResponse<FileManagerDirectoryContent>();
            response.Files = await fs.createFolder(id, args);
            await Task.Yield();
            args.Response = response;
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on FolderCreatingAsync");
            nm.sendMessage("Error", "Error on FolderCreatingAsync", NotificationTypes.Error);
        }

    }

    public async Task BeforeImageLoadAsync(BeforeImageLoadEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            using HttpClient Http = new HttpClient();
            var str = await Http.GetStreamAsync($"https://localhost:7205/api/file/GetImage?path={HttpUtility.UrlEncode(args.ImageUrl)}");
            args.FileStream = str;
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on BeforeImageLoadAsync");
            nm.sendMessage("Error", "Error on BeforeImageLoadAsync", NotificationTypes.Error);
        }
    }

    private async Task OnReadAsync(ReadEventArgs<FileManagerDirectoryContent> args)
    {
        try
        {
            string path = args.Path;
            List<FileManagerDirectoryContent> fileDetails = args.Folder;

            args.Response = isShared ? await fs.GetFilesPath(DbService.SHARED_DB_NAME, path, fileDetails, bsi.CollectionId) : await fs.GetFilesPath(id, path, fileDetails);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnReadAsync");
            nm.sendMessage("Error", "Error on OnReadAsync", NotificationTypes.Error);
        }

    }

    #endregion

    #region Mobile FileManager Events

    private async Task OnMobileReadAsync(MfmReadEventArgs args)
    {
        try
        {
            args.Response = isShared
                ? await fs.GetFilesPath(DbService.SHARED_DB_NAME, args.Path, null, bsi.CollectionId)
                : await fs.GetFilesPath(id, args.Path, null);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileReadAsync");
            nm.sendMessage("Error", "Error on OnMobileReadAsync", NotificationTypes.Error);
        }
    }

    private async Task OnMobileItemsDeletingAsync(MfmDeleteEventArgs args)
    {
        try
        {
            foreach (var file in args.Files)
            {
                await fs.oneItemDeleteAsync(id, file);
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileItemsDeletingAsync");
            nm.sendMessage("Error", "Error on delete", NotificationTypes.Error);
        }
    }

    private async Task OnMobileItemsMovingAsync(MfmMoveEventArgs args)
    {
        try
        {
            // Normalize paths to use forward slashes
            var targetPath = args.TargetPath?.Replace("\\", "/") ?? "/";
            var sourcePath = args.SourcePath?.Replace("\\", "/") ?? "/";

            // Normalize FilterPath in files
            var normalizedFiles = args.Files.Select(f => {
                f.FilterPath = f.FilterPath?.Replace("\\", "/");
                return f;
            }).ToArray();

            var targetData = args.TargetData;
            if (targetData != null)
            {
                targetData.FilterPath = targetData.FilterPath?.Replace("\\", "/");
            }
            else
            {
                targetData = new FileManagerDirectoryContent
                {
                    FilterPath = targetPath,
                    IsFile = false,
                    Name = targetPath.TrimEnd('/').Split('/').LastOrDefault() ?? ""
                };
            }

            args.Response = await fs.CopyOrMoveItems(id, normalizedFiles, targetPath, targetData, args.IsCopy);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileItemsMovingAsync");
            nm.sendMessage("Error", "Error on move/copy", NotificationTypes.Error);
        }
    }

    private async Task OnMobileItemRenamingAsync(MfmRenameEventArgs args)
    {
        try
        {
            if (args.File != null)
            {
                args.Response = await fs.RenameFileOrFolder(id, args.File, args.NewName);
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileItemRenamingAsync");
            nm.sendMessage("Error", "Error on rename", NotificationTypes.Error);
        }
    }

    private async Task OnMobileFolderCreatingAsync(MfmFolderCreateEventArgs args)
    {
        try
        {
            FileManagerResponse<FileManagerDirectoryContent> response = new FileManagerResponse<FileManagerDirectoryContent>();

            // Use the ParentFolder from args which has the correct Id
            response.Files = await fs.createFolder(id, args.Path, args.FolderName, args.ParentFolder);

            args.Response = response;
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileFolderCreatingAsync");
            nm.sendMessage("Error", "Error on create folder", NotificationTypes.Error);
        }
    }

    private async Task OnMobileSearchingAsync(MfmSearchEventArgs args)
    {
        try
        {
            args.Response = isShared
                ? await fs.SearchAsync(DbService.SHARED_DB_NAME, args.Path, args.SearchText, bsi.CollectionId)
                : await fs.SearchAsync(id, args.Path, args.SearchText);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileSearchingAsync");
            nm.sendMessage("Error", "Error on search", NotificationTypes.Error);
        }
    }

    private async Task OnMobileFileOpenAsync(MfmFileOpenEventArgs args)
    {
        if (args.FileDetails == null || !args.FileDetails.IsFile)
            return;

        args.Cancel = true;

        if (isAudioFile(args.FileDetails.Type?.ToLower() ?? ""))
        {
            await playAudio(args.FileDetails);
            return;
        }

        if (isVideoFile(args.FileDetails.Type?.ToLower() ?? ""))
        {
            videoPlayer.ShowModal(await getVideoUrl(args.FileDetails.Id, args.FileDetails.Name, args.FileDetails.Size), args.FileDetails.Name);
            return;
        }

        if (isPdfFile(args.FileDetails.Type?.ToLower() ?? ""))
        {
            var pdfUrl = await getPdfViewUrl(args.FileDetails.Id, args.FileDetails.Name, args.FileDetails.Size);
            await pdfViewer.ShowModal(pdfUrl, args.FileDetails.Name);
            return;
        }

        if (isImageFile(args.FileDetails.Type?.ToLower() ?? ""))
        {
            await OpenImageViewerMobile(args.FileDetails);
            return;
        }

        string filePath = getTempFileMediaUrl(args.FileDetails.Id, args.FileDetails.Name);
        await JSRuntime.InvokeVoidAsync("open", filePath, "_blank");
    }

    private async Task OnMobileBeforeDownloadAsync(MfmDownloadEventArgs args)
    {
        try
        {
            if (isShared)
                await fs.downloadFile(DbService.SHARED_DB_NAME, args.Path, args.Names.ToList(), null, bsi.CollectionId);
            else
                await fs.downloadFile(id, args.Path, args.Names.ToList(), null);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileBeforeDownloadAsync");
            nm.sendMessage("Error", "Error on download", NotificationTypes.Error);
        }
    }

    private async Task OnMobileDownloadToLocalAsync(MfmDownloadToLocalEventArgs args)
    {
        try
        {
            Modal.id = id;
            Modal.filePath = args.Files.FirstOrDefault()?.IsFile == true
                ? args.Files.FirstOrDefault()?.FilterPath?.Replace("\\", "/")
                : args.Files.FirstOrDefault()?.FilterPath?.Replace("\\", "/") + args.Files.FirstOrDefault()?.Name + "/";
            Modal.fileList = args.Files.ToList();
            Modal.Open();
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileDownloadToLocalAsync");
            nm.sendMessage("Error", "Error opening download dialog", NotificationTypes.Error);
        }
    }

    private async Task OnMobileShareFileAsync(MfmShareFileEventArgs args)
    {
        try
        {
            if (args.File != null)
            {
                MyNavigationManager.NavigateTo("/api/file/share/" + id + $"?bsonId={args.File.Id}&fileName={args.File.Name}", true);
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileShareFileAsync");
            nm.sendMessage("Error", "Error sharing file", NotificationTypes.Error);
        }
    }

    private async Task OnMobileShowInAppAsync(MfmShowInAppEventArgs args)
    {
        try
        {
            if (args.File != null)
            {
                var item = await fs.getItemById(id, args.File.Id);
                if (item.IsFile)
                    await JSRuntime.InvokeVoidAsync("open", $"tg://privatepost?channel={id}&post={item.MessageId ?? item.ListMessageId.FirstOrDefault()}", "_blank");
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileShowInAppAsync");
            nm.sendMessage("Error", "Error opening in app", NotificationTypes.Error);
        }
    }

    private async Task OnMobileUrlMediaAsync(MfmUrlMediaEventArgs args)
    {
        try
        {
            if (args.File != null)
            {
                var fileType = args.File.Type?.ToLower() ?? "";
                bool forcePreDownload = !(isAudioFile(fileType) || isVideoFile(fileType));
                await ShowMediaURLModal(args.File.Id, args.File.Name, args.File.Size, forcePreDownload);
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileUrlMediaAsync");
            nm.sendMessage("Error", "Error showing media URL", NotificationTypes.Error);
        }
    }

    private async Task OnMobileStrmAsync(MfmStrmEventArgs args)
    {
        try
        {
            if (args.Folder != null)
            {
                var path = args.Folder.FilterPath + args.Folder.Name + "/";
                exportStrmModal.Open(id, path, MyNavigationManager.BaseUri);
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileStrmAsync");
            nm.sendMessage("Error", "Error generating STRM files", NotificationTypes.Error);
        }
        await Task.CompletedTask;
    }

    private void OnStrmExportCompleted(string message)
    {
        if (message.StartsWith("Error"))
        {
            nm.sendMessage("Export Error", message, NotificationTypes.Error);
        }
        else
        {
            nm.sendMessage("Export Complete", message, NotificationTypes.Success);
        }
    }

    private async Task OnMobilePreloadFilesAsync(MfmPreloadFilesEventArgs args)
    {
        try
        {
            if (args.Items.Length > 0)
            {
                nm.sendMessage("Preload", $"Starting preload of {args.Items.Length} items to cache...", NotificationTypes.Info);
                var channelId = isShared ? bsi.ChannelId : id;
                _ = Task.Run(async () =>
                {
                    var count = await fs.PreloadFilesToTemp(channelId, args.Items.ToList());
                    nm.sendMessage("Preload Complete", $"Preloaded {count} files to cache", NotificationTypes.Success);
                });
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobilePreloadFilesAsync");
            nm.sendMessage("Error", "Error preloading files", NotificationTypes.Error);
        }
    }

    private async Task OnMobileAddToPlaylistAsync(MfmAddToPlaylistEventArgs args)
    {
        try
        {
            if (args.IsMultiple && args.Files.Length > 0)
            {
                int addedCount = 0;
                foreach (var file in args.Files)
                {
                    var url = await getMediaUrl(file.Id, file.Name, file.Size);
                    await JSRuntime.InvokeVoidAsync("addToAudioPlaylist", url, "audio/mpeg", file.Name);
                    addedCount++;
                }
                nm.sendMessage("Playlist", $"Added {addedCount} tracks to playlist", NotificationTypes.Success);
            }
            else if (args.File != null)
            {
                var url = await getMediaUrl(args.File.Id, args.File.Name, args.File.Size);
                await JSRuntime.InvokeVoidAsync("addToAudioPlaylist", url, null, args.File.Name);
                nm.sendMessage("Playlist", $"Added '{args.File.Name}' to playlist", NotificationTypes.Success);
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileAddToPlaylistAsync");
            nm.sendMessage("Error", "Error adding to playlist", NotificationTypes.Error);
        }
    }

    private async Task OnMobileSaveToPlaylistAsync(MfmSaveToPlaylistEventArgs args)
    {
        try
        {
            var tracks = new List<PlaylistTrackModel>();
            var channelId = isShared ? bsi.ChannelId : id;
            var channelName = isShared ? bsi.Name : channelId;

            if (args.IsMultiple && args.Files.Length > 0)
            {
                foreach (var file in args.Files)
                {
                    tracks.Add(new PlaylistTrackModel
                    {
                        FileId = file.Id,
                        ChannelId = channelId,
                        ChannelName = channelName,
                        FileName = file.Name,
                        FileType = Path.GetExtension(file.Name).TrimStart('.').ToLowerInvariant(),
                        FileSize = file.Size,
                        Order = tracks.Count
                    });
                }
            }
            else if (args.File != null)
            {
                tracks.Add(new PlaylistTrackModel
                {
                    FileId = args.File.Id,
                    ChannelId = channelId,
                    ChannelName = channelName,
                    FileName = args.File.Name,
                    FileType = Path.GetExtension(args.File.Name).TrimStart('.').ToLowerInvariant(),
                    FileSize = args.File.Size,
                    Order = 0
                });
            }

            if (tracks.Count > 0)
            {
                var saveModal = MainLayout.GetSaveToPlaylistModal();
                if (saveModal != null)
                {
                    await saveModal.Open(tracks);
                }
            }
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error on OnMobileSaveToPlaylistAsync");
            nm.sendMessage("Error", "Error saving to playlist", NotificationTypes.Error);
        }
    }

    #endregion

    #region Shared Helper Methods

    private bool isVideoFile(string fileExtension)
    {
        // Native browser formats - always playable
        var nativeFormats = new List<string> { ".mov", ".mp4", ".m4v", ".ogv", ".webm", ".flv", ".f4v" };

        if (nativeFormats.Contains(fileExtension))
            return true;

        // Transcoding formats - only playable if transcoding is enabled
        if (GeneralConfigStatic.config.EnableVideoTranscoding)
        {
            var transcodingFormats = new List<string> { ".mkv", ".avi", ".wmv", ".ts", ".mts", ".m2ts", ".vob", ".divx", ".xvid", ".3gp" };
            return transcodingFormats.Contains(fileExtension);
        }

        return false;
    }

    private bool needsTranscoding(string fileExtension)
    {
        return new List<string> { ".mkv", ".avi", ".wmv", ".ts", ".mts", ".m2ts", ".vob", ".divx", ".xvid", ".3gp" }.Contains(fileExtension);
    }

    private bool isAudioFile(string fileExtension)
    {
        return new List<string> { ".mp3", ".ogg", ".flac", ".aac", ".wav" }.Contains(fileExtension);
    }

    private bool isPdfFile(string fileExtension)
    {
        return fileExtension == ".pdf";
    }

    private bool isImageFile(string fileExtension)
    {
        return new List<string> { ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".svg", ".ico", ".tiff", ".tif" }.Contains(fileExtension);
    }

    private async Task playAudio(FileManagerDirectoryContent fileDetails)
    {
        try
        {
            var url = await getMediaUrl(fileDetails.Id, fileDetails.Name, fileDetails.Size);
            await JSRuntime.InvokeVoidAsync("openAudioPlayerModal", url, null, fileDetails.Name);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Error playing audio file: {Name}", fileDetails.Name);
            nm.sendMessage("Error", "Error playing audio file", NotificationTypes.Error);
        }
    }

    private async Task OpenImageViewer(FileManagerDirectoryContent clickedImage)
    {
        try
        {
            // Get current path from desktop file manager
            var currentPath = fm?.Path ?? "/";

            // Get all files in current folder
            var response = isShared
                ? await fs.GetFilesPath(DbService.SHARED_DB_NAME, currentPath, null, bsi.CollectionId)
                : await fs.GetFilesPath(id, currentPath, null);

            // Filter to only images and build ImageInfo list
            var imageFiles = response?.Files?
                .Where(f => f.IsFile && isImageFile(f.Type?.ToLower() ?? ""))
                .OrderBy(f => f.Name)
                .ToList() ?? new List<FileManagerDirectoryContent>();

            if (imageFiles.Count == 0)
            {
                // Fallback: just show the clicked image
                var url = await getImageViewUrl(clickedImage.Id, clickedImage.Name, clickedImage.Size);
                await imageViewer.ShowModal(url, clickedImage.Name);
                return;
            }

            // Build list of ImageInfo
            var imageInfoList = new List<ImageViewerModal.ImageInfo>();
            int startIndex = 0;

            for (int i = 0; i < imageFiles.Count; i++)
            {
                var file = imageFiles[i];
                var url = await getImageViewUrl(file.Id, file.Name, file.Size);
                imageInfoList.Add(new ImageViewerModal.ImageInfo { Url = url, FileName = file.Name });

                if (file.Id == clickedImage.Id)
                {
                    startIndex = i;
                }
            }

            await imageViewer.ShowModal(imageInfoList, startIndex);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error opening image viewer");
            // Fallback: just show the clicked image
            var url = await getImageViewUrl(clickedImage.Id, clickedImage.Name, clickedImage.Size);
            await imageViewer.ShowModal(url, clickedImage.Name);
        }
    }

    private async Task OpenImageViewerMobile(FileManagerDirectoryContent clickedImage)
    {
        try
        {
            // Get current path from mobile file manager
            var currentPath = mobileFileManager?.Path ?? "/";

            // Get all files in current folder
            var response = isShared
                ? await fs.GetFilesPath(DbService.SHARED_DB_NAME, currentPath, null, bsi.CollectionId)
                : await fs.GetFilesPath(id, currentPath, null);

            // Filter to only images and build ImageInfo list
            var imageFiles = response?.Files?
                .Where(f => f.IsFile && isImageFile(f.Type?.ToLower() ?? ""))
                .OrderBy(f => f.Name)
                .ToList() ?? new List<FileManagerDirectoryContent>();

            if (imageFiles.Count == 0)
            {
                // Fallback: just show the clicked image
                var url = await getImageViewUrl(clickedImage.Id, clickedImage.Name, clickedImage.Size);
                await imageViewer.ShowModal(url, clickedImage.Name);
                return;
            }

            // Build list of ImageInfo
            var imageInfoList = new List<ImageViewerModal.ImageInfo>();
            int startIndex = 0;

            for (int i = 0; i < imageFiles.Count; i++)
            {
                var file = imageFiles[i];
                var url = await getImageViewUrl(file.Id, file.Name, file.Size);
                imageInfoList.Add(new ImageViewerModal.ImageInfo { Url = url, FileName = file.Name });

                if (file.Id == clickedImage.Id)
                {
                    startIndex = i;
                }
            }

            await imageViewer.ShowModal(imageInfoList, startIndex);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error opening image viewer (mobile)");
            // Fallback: just show the clicked image
            var url = await getImageViewUrl(clickedImage.Id, clickedImage.Name, clickedImage.Size);
            await imageViewer.ShowModal(url, clickedImage.Name);
        }
    }

    private async Task ShowMediaURLModal(string idFile, String name, long size, bool forcePreDownload = false)
    {
        mediaUrlModal.url = await getMediaUrl(idFile, name, size, forcePreDownload);
        await mediaUrlModal.OnShowModalClick();
    }

    private async Task<string> getMediaUrl(string idFile, String name, long size, bool forcePreDownload = false)
    {
        BsonFileManagerModel item = null;
        if (isShared)
            item = await fs.getSharedItemById(id: idFile, collection: bsi.CollectionId);
        else
            item = await fs.getItemById(id, idFile);
        string localdir = MyNavigationManager.BaseUri;
        var channelId = isShared ? bsi.ChannelId : id;

        // Always use GetFileStream format with MongoDB document ID for consistency
        // This ensures playlist functionality can extract channelId and fileId correctly
        if (forcePreDownload || (HelperService.bytesToMegaBytes(size) <= GeneralConfigStatic.config.MaxPreloadFileSizeInMb && item != null && item.MessageId != null))
        {
            // Still use the preload endpoint but append the file ID info in a way that's extractable
            return new System.Uri(Path.Combine(localdir, "api/file/GetFile", name).Replace("\\", "/") + $"?idChannel={channelId}&idFile={item.MessageId}&docId={idFile}").AbsoluteUri;
        }
        return new System.Uri(Path.Combine(localdir, "api/file/GetFileStream", channelId, idFile, name).Replace("\\", "/")).AbsoluteUri;
    }

    private async Task<string> getVideoUrl(string idFile, String name, long size)
    {
        var extension = Path.GetExtension(name).ToLowerInvariant();
        string localdir = MyNavigationManager.BaseUri;
        var channelId = isShared ? bsi.ChannelId : id;

        // Use transcoding endpoint for non-native formats
        if (needsTranscoding(extension))
        {
            return new System.Uri(Path.Combine(localdir, "api/video/stream", channelId, idFile, name).Replace("\\", "/")).AbsoluteUri;
        }

        // Use regular stream for native formats
        return await getMediaUrl(idFile, name, size);
    }

    private async Task<string> getPdfViewUrl(string idFile, String name, long size)
    {
        BsonFileManagerModel item = null;
        if (isShared)
            item = await fs.getSharedItemById(id: idFile, collection: bsi.CollectionId);
        else
            item = await fs.getItemById(id, idFile);
        string localdir = MyNavigationManager.BaseUri;

        // Use ViewFile endpoint which serves with Content-Disposition: inline
        if (item != null && item.MessageId != null)
        {
            return new System.Uri(Path.Combine(localdir, "api/file/ViewFile", name).Replace("\\", "/") + $"?idChannel={(isShared ? bsi.ChannelId : id)}&idFile={item.MessageId}").AbsoluteUri;
        }
        // Fallback to stream endpoint
        return new System.Uri(Path.Combine(localdir, "api/file/GetFileStream", isShared ? bsi.ChannelId : id, idFile, name).Replace("\\", "/")).AbsoluteUri;
    }

    private async Task<string> getImageViewUrl(string idFile, String name, long size)
    {
        BsonFileManagerModel item = null;
        if (isShared)
            item = await fs.getSharedItemById(id: idFile, collection: bsi.CollectionId);
        else
            item = await fs.getItemById(id, idFile);
        string localdir = MyNavigationManager.BaseUri;

        // Use ViewFile endpoint which serves with Content-Disposition: inline
        if (item != null && item.MessageId != null)
        {
            return new System.Uri(Path.Combine(localdir, "api/file/ViewFile", name).Replace("\\", "/") + $"?idChannel={(isShared ? bsi.ChannelId : id)}&idFile={item.MessageId}").AbsoluteUri;
        }
        // Fallback to stream endpoint
        return new System.Uri(Path.Combine(localdir, "api/file/GetFileStream", isShared ? bsi.ChannelId : id, idFile, name).Replace("\\", "/")).AbsoluteUri;
    }

    private string getTempFileMediaUrl(string idFile, String name)
    {
        string localdir = MyNavigationManager.BaseUri;
        return new System.Uri(Path.Combine(localdir, "api/file/GetFileByTfmIdNow", name).Replace("\\", "/") + $"?idChannel={(isShared ? bsi.ChannelId : id)}&idFile={idFile}").AbsoluteUri;
    }

    private void doToolbarItemInvisible(String name)
    {
        Items.Where(x => name.Equals(x.Name)).ToList().ForEach(x => x.Visible = false);
    }

    #endregion
}
