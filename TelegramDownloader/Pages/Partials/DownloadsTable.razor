@using TelegramDownloader.Data
@using TelegramDownloader.Models
@using TelegramDownloader.Services
@using TelegramDownloader.Pages.Modals.InfoModals
@implements IDisposable

@inject TransactionInfoService tis

<Grid @ref="grid"
      TItem="DownloadModel"
      Class="table"
      DataProvider="DownloadsDataProvider"
      AllowFiltering="false"
      AllowPaging="true"
      AllowSorting="false"
      Responsive="true"
      ItemsPropertyName="_internalId">

    <GridColumn TItem="DownloadModel" HeaderText="File" PropertyName="name" HeaderTextAlignment="Alignment.Start" TextAlignment="Alignment.Start">
        <div class="file-name">
            <div class="file-icon">
                <i class="bi @GetFileIcon(context.name)"></i>
            </div>
            <div class="file-info">
                <div class="file-title" title="@context.name">@context.name</div>
                <div class="file-channel">
                    <i class="bi bi-broadcast"></i>
                    @context.channelName
                </div>
            </div>
        </div>
    </GridColumn>

    <GridColumn TItem="DownloadModel" HeaderText="Progress" PropertyName="progress">
        <div class="progress-container">
            <div class="progress-wrapper">
                <div class="progress-stats">
                    <span class="progress-percent @(context.progress >= 100 ? "complete" : "")">@context.progress%</span>
                    <span class="progress-size">@context._transmittedString / @context._sizeString</span>
                </div>
                <div class="progress">
                    <div class="progress-bar @GetProgressClass(context)"
                         role="progressbar"
                         style="width: @context.progress%;"
                         aria-valuenow="@context.progress"
                         aria-valuemin="0"
                         aria-valuemax="100">
                    </div>
                </div>
            </div>
        </div>
    </GridColumn>

    <GridColumn TItem="DownloadModel" HeaderText="Status">
        <span class="status-badge @GetStatusClass(context, isPending)">
            <i class="bi @GetStatusIcon(context, isPending)"></i>
            @GetStatusText(context, isPending)
        </span>
    </GridColumn>

    <GridColumn TItem="DownloadModel" HeaderText="Actions">
        <div class="action-buttons">
            @if (context.state == StateTask.Working && !isPending)
            {
                <button class="action-btn cancel" @onclick="() => cancel(context)" title="Cancel">
                    <i class="bi bi-x-lg"></i>
                </button>
            }

            @if ((context.state == StateTask.Canceled || context.state == StateTask.Error) && !isPending)
            {
                <button class="action-btn retry" @onclick="() => retry(context)" title="Retry">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
            }

            @if (context.state == StateTask.Canceled || context.state == StateTask.Error || isPending)
            {
                <button class="action-btn delete" @onclick="() => deleteDownload(context)" title="Delete">
                    <i class="bi bi-trash3"></i>
                </button>
            }

            <button class="action-btn info" @onclick="() => infoModal.ShowModal(context)" title="Info">
                <i class="bi bi-info-lg"></i>
            </button>
        </div>
    </GridColumn>

</Grid>

<TelegramDownloader.Pages.Modals.InfoModals.DownloadFileInfoModal @ref="infoModal"></TelegramDownloader.Pages.Modals.InfoModals.DownloadFileInfoModal>

@code {
    [Parameter]
    public bool isPending { get; set; } = false;
    public static List<DownloadModel> ldm = new List<DownloadModel>();
    BlazorBootstrap.Grid<DownloadModel> grid = default!;
    DownloadFileInfoModal infoModal { get; set; }
    private bool _disposed = false;

    private string GetFileIcon(string fileName)
    {
        if (string.IsNullOrEmpty(fileName)) return "bi-file-earmark";

        var ext = Path.GetExtension(fileName)?.ToLower();
        return ext switch
        {
            ".mp4" or ".mkv" or ".avi" or ".mov" or ".wmv" or ".webm" => "bi-film",
            ".mp3" or ".wav" or ".flac" or ".aac" or ".ogg" or ".m4a" => "bi-music-note-beamed",
            ".jpg" or ".jpeg" or ".png" or ".gif" or ".bmp" or ".webp" => "bi-image",
            ".pdf" => "bi-file-earmark-pdf",
            ".doc" or ".docx" => "bi-file-earmark-word",
            ".xls" or ".xlsx" => "bi-file-earmark-excel",
            ".zip" or ".rar" or ".7z" or ".tar" or ".gz" => "bi-file-earmark-zip",
            _ => "bi-file-earmark"
        };
    }

    private string GetProgressClass(DownloadModel dm)
    {
        if (dm.state == StateTask.Completed || dm.progress >= 100) return "complete";
        if (dm.state == StateTask.Error || dm.state == StateTask.Canceled) return "error";
        return "";
    }

    private string GetStatusClass(DownloadModel dm, bool pending)
    {
        if (pending) return "pending";
        return dm.state switch
        {
            StateTask.Working => "working",
            StateTask.Completed => "completed",
            StateTask.Error => "error",
            StateTask.Canceled => "canceled",
            _ => "pending"
        };
    }

    private string GetStatusIcon(DownloadModel dm, bool pending)
    {
        if (pending) return "bi-clock";
        return dm.state switch
        {
            StateTask.Working => "bi-arrow-down-circle",
            StateTask.Completed => "bi-check-circle",
            StateTask.Error => "bi-exclamation-circle",
            StateTask.Canceled => "bi-slash-circle",
            _ => "bi-clock"
        };
    }

    private string GetStatusText(DownloadModel dm, bool pending)
    {
        if (pending) return "Pending";
        return dm.state switch
        {
            StateTask.Working => "Downloading",
            StateTask.Completed => "Completed",
            StateTask.Error => "Error",
            StateTask.Canceled => "Canceled",
            _ => "Pending"
        };
    }

    protected override async Task OnInitializedAsync()
    {
        checkNewEventsHandler();
        tis.EventChanged += eventChangedNew;
    }

    private async Task<GridDataProviderResult<DownloadModel>> DownloadsDataProvider(GridDataProviderRequest<DownloadModel> request)
    {
        await getDownloadModels(request.PageNumber - 1, request.PageSize, ldm.Count() == 0);
        int totalUploads = tis.getTotalDownloads(isPending);
        return await Task.FromResult(new GridDataProviderResult<DownloadModel> { Data = ldm ?? new List<DownloadModel>(), TotalCount = totalUploads });//request.ApplyTo(uploads));
    }

    private async Task cancel(DownloadModel dm)
    {
        //um.thread.Interrupt();
        dm.Cancel();
        await InvokeAsync(StateHasChanged);
    }

    private async Task retry(DownloadModel dm)
    {
        //um.thread.Interrupt();
        dm.RetryCallback();
        await InvokeAsync(StateHasChanged);
    }

    private async Task deleteDownload(DownloadModel um)
    {
        if (isPending) {
            tis.deletePendingDownloadInList(um);
            return;
        }
        tis.deleteDownloadInList(um);
    }


    private void checkNewEventsHandler()
    {
        foreach (DownloadModel dm in ldm)
        {
            if (dm.progress != 100)
                dm.EventChanged += eventChanged;
            else
                dm.EventChanged -= eventChanged;
        }

    }

    private async Task getDownloadModels(int pageNumber, int pageSize, bool mustCallEnventHandler = false)
    {
        ldm = tis.GetDownloadModels(pageNumber, pageSize, isPending);
        if (mustCallEnventHandler)
            checkNewEventsHandler();
    }

    void eventChanged(object sender, DownloadEventArgs e)
    {
        if (_disposed) return;
        grid.RefreshDataAsync();
    }

    void eventChangedNew(object sender, System.EventArgs e)
    {
        if (_disposed) return;
        checkNewEventsHandler();
        grid.RefreshDataAsync();
    }

    public void Dispose()
    {
        _disposed = true;
        tis.EventChanged -= eventChangedNew;
        foreach (DownloadModel dm in ldm)
        {
            dm.EventChanged -= eventChanged;
        }
    }
}
