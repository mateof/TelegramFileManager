@using TelegramDownloader.Shared
@using TelegramDownloader.Data.db
@inject IJSRuntime JSRuntime
@inject IDbService DbService
@implements IDisposable

<style>
    /* Floating Audio Player */
    .audio-player-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        z-index: 1050;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
    }

    .audio-player-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    /* Desktop Layout - Two columns */
    .audio-player-container {
        width: 100%;
        max-width: 900px;
        max-height: 90vh;
        margin: 1rem;
        background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
        border-radius: 1.25rem;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5),
                    0 0 0 1px rgba(233, 69, 96, 0.1);
        overflow: hidden;
        transform: scale(0.9) translateY(20px);
        transition: transform 0.3s ease;
        position: relative;
        display: flex;
        flex-direction: row;
    }

    .audio-player-overlay.show .audio-player-container {
        transform: scale(1) translateY(0);
    }

    /* Main player section */
    .audio-player-main {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
    }

    /* Saved playlists sidebar - Desktop only */
    .audio-player-sidebar {
        width: 280px;
        background: rgba(0, 0, 0, 0.3);
        border-left: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .sidebar-header {
        padding: 1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: rgba(255, 255, 255, 0.8);
        font-weight: 500;
    }

    .sidebar-header i {
        color: #e94560;
    }

    .saved-playlists-list {
        flex: 1;
        overflow-y: auto;
        padding: 0.5rem;
    }

    .saved-playlist-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem;
        border-radius: 0.5rem;
        cursor: pointer;
        transition: all 0.2s;
        margin-bottom: 0.25rem;
    }

    .saved-playlist-item:hover {
        background: rgba(233, 69, 96, 0.15);
    }

    .saved-playlist-item.active {
        background: rgba(233, 69, 96, 0.25);
    }

    .saved-playlist-icon {
        width: 40px;
        height: 40px;
        background: linear-gradient(135deg, #e94560 0%, #0f3460 100%);
        border-radius: 0.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        flex-shrink: 0;
    }

    .saved-playlist-info {
        flex: 1;
        min-width: 0;
    }

    .saved-playlist-name {
        color: white;
        font-size: 0.9rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .saved-playlist-count {
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.75rem;
    }

    .saved-playlist-play {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: none;
        background: #e94560;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0;
        transition: all 0.2s;
    }

    .saved-playlist-item:hover .saved-playlist-play {
        opacity: 1;
    }

    .saved-playlist-play:hover {
        transform: scale(1.1);
    }

    /* Close button */
    .audio-close-btn {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: none;
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.7);
        font-size: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        z-index: 10;
    }

    .audio-close-btn:hover {
        background: rgba(233, 69, 96, 0.3);
        color: #fff;
        transform: rotate(90deg);
    }

    /* Player content */
    .audio-player-content {
        padding: 1.5rem;
        flex: 1;
        overflow-y: auto;
    }

    /* Current playlist name badge */
    .current-playlist-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        background: rgba(233, 69, 96, 0.2);
        border: 1px solid rgba(233, 69, 96, 0.3);
        border-radius: 1rem;
        padding: 0.25rem 0.75rem;
        margin-bottom: 1rem;
        color: #e94560;
        font-size: 0.8rem;
    }

    .current-playlist-badge i {
        font-size: 0.9rem;
    }

    /* Album art */
    .album-art {
        width: 160px;
        height: 160px;
        background: linear-gradient(135deg, #0f3460 0%, #e94560 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 1.25rem;
        box-shadow: 0 8px 32px rgba(233, 69, 96, 0.3);
        animation: album-rotate 8s linear infinite;
        animation-play-state: paused;
        position: relative;
    }

    .album-art::before {
        content: '';
        position: absolute;
        width: 28px;
        height: 28px;
        background: #1a1a2e;
        border-radius: 50%;
        z-index: 1;
    }

    .album-art.playing {
        animation-play-state: running;
    }

    .album-art i {
        font-size: 3rem;
        color: rgba(255, 255, 255, 0.9);
        z-index: 0;
    }

    .album-art-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
        z-index: 0;
    }

    @@keyframes album-rotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    /* Audio title display */
    .audio-title-display {
        background: linear-gradient(135deg, rgba(233, 69, 96, 0.1) 0%, rgba(15, 52, 96, 0.2) 100%);
        border: 1px solid rgba(233, 69, 96, 0.2);
        border-radius: 0.75rem;
        padding: 0.875rem 1rem;
        margin-bottom: 1rem;
        color: #fff;
        font-weight: 500;
        font-size: 0.95rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        overflow: hidden;
    }

    .audio-title-display i {
        font-size: 1.125rem;
        color: #e94560;
        flex-shrink: 0;
    }

    .audio-title-display .title-wrapper {
        flex: 1;
        overflow: hidden;
        position: relative;
        mask-image: linear-gradient(90deg, transparent, #000 5%, #000 95%, transparent);
        -webkit-mask-image: linear-gradient(90deg, transparent, #000 5%, #000 95%, transparent);
    }

    .audio-title-display .title-text {
        white-space: nowrap;
        display: inline-block;
    }

    .audio-title-display .title-text.scrolling {
        animation: marquee-scroll 10s linear infinite;
        padding-right: 50px;
    }

    .audio-title-display .title-text.scrolling::after {
        content: attr(data-text);
        position: absolute;
        left: 100%;
        padding-left: 50px;
    }

    @@keyframes marquee-scroll {
        0% { transform: translateX(0); }
        100% { transform: translateX(-50%); }
    }

    /* Loading Indicator */
    .audio-loading-indicator {
        height: 60px;
        background: linear-gradient(135deg, rgba(233, 69, 96, 0.05) 0%, rgba(15, 52, 96, 0.1) 100%);
        border-radius: 0.5rem;
        margin-bottom: 1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        padding: 0.5rem;
    }

    .loading-spinner {
        width: 24px;
        height: 24px;
        border: 2px solid rgba(233, 69, 96, 0.3);
        border-top-color: #e94560;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @@keyframes spin {
        to { transform: rotate(360deg); }
    }

    .loading-text {
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.8rem;
    }

    .loading-progress {
        width: 80%;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
    }

    .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #e94560 0%, #ff6b6b 100%);
        border-radius: 2px;
        transition: width 0.3s ease;
    }

    .loading-percent {
        color: #e94560;
        font-size: 0.75rem;
        font-weight: 600;
    }

    /* Visualizer */
    .audio-visualizer {
        height: 60px;
        background: linear-gradient(135deg, rgba(233, 69, 96, 0.05) 0%, rgba(15, 52, 96, 0.1) 100%);
        border-radius: 0.5rem;
        margin-bottom: 1rem;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        gap: 4px;
        padding: 0.5rem;
        overflow: hidden;
    }

    .audio-visualizer.paused .bar {
        animation-play-state: paused;
    }

    .audio-visualizer .bar {
        width: 5px;
        background: linear-gradient(180deg, #e94560 0%, #0f3460 100%);
        border-radius: 2px;
        animation: equalizer 0.8s ease-in-out infinite;
    }

    .audio-visualizer:not(.real-time) .bar:nth-child(1) { height: 20%; animation-delay: 0s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(2) { height: 40%; animation-delay: 0.1s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(3) { height: 60%; animation-delay: 0.2s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(4) { height: 80%; animation-delay: 0.3s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(5) { height: 100%; animation-delay: 0.4s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(6) { height: 80%; animation-delay: 0.5s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(7) { height: 60%; animation-delay: 0.6s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(8) { height: 40%; animation-delay: 0.7s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(9) { height: 20%; animation-delay: 0.8s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(10) { height: 40%; animation-delay: 0.9s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(11) { height: 60%; animation-delay: 1s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(12) { height: 80%; animation-delay: 1.1s; }
    .audio-visualizer:not(.real-time) .bar:nth-child(13) { height: 60%; animation-delay: 1.2s; }

    .audio-visualizer.real-time .bar {
        animation: none;
        transition: height 0.05s ease-out;
        min-height: 5%;
    }

    @@keyframes equalizer {
        0%, 100% { transform: scaleY(0.3); }
        50% { transform: scaleY(1); }
    }

    /* Custom Audio Controls */
    .audio-controls {
        background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
        border-radius: 0.75rem;
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .audio-main-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1.25rem;
    }

    .audio-btn-nav {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .audio-btn-nav:hover {
        background: rgba(233, 69, 96, 0.3);
    }

    .audio-btn-nav:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

    .audio-btn-repeat {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: none;
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.6);
        font-size: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
    }

    .audio-btn-repeat:hover {
        background: rgba(233, 69, 96, 0.2);
        color: white;
    }

    .audio-btn-repeat.active {
        color: #e94560;
    }

    .audio-btn-repeat .repeat-badge {
        position: absolute;
        top: -2px;
        right: -2px;
        width: 14px;
        height: 14px;
        background: #e94560;
        border-radius: 50%;
        font-size: 0.6rem;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
    }

    .audio-controls-row {
        display: flex;
        align-items: center;
        gap: 1rem;
    }

    .audio-btn-play {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: none;
        background: linear-gradient(135deg, #e94560 0%, #c73659 100%);
        color: white;
        font-size: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
    }

    .audio-btn-play:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
    }

    .audio-progress-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .audio-seek-slider {
        width: 100%;
        height: 6px;
        -webkit-appearance: none;
        appearance: none;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        cursor: pointer;
        outline: none;
    }

    .audio-seek-slider::-webkit-slider-runnable-track {
        height: 6px;
        background: transparent;
        border-radius: 3px;
    }

    .audio-seek-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: #fff;
        border-radius: 50%;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        margin-top: -5px;
        transition: transform 0.1s ease, box-shadow 0.2s ease;
    }

    .audio-seek-slider::-webkit-slider-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 2px 10px rgba(233, 69, 96, 0.5);
    }

    .audio-seek-slider::-moz-range-track {
        height: 6px;
        background: transparent;
        border-radius: 3px;
    }

    .audio-seek-slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: #fff;
        border-radius: 50%;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        border: none;
    }

    .audio-time {
        display: flex;
        justify-content: space-between;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.7);
    }

    .audio-secondary-controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding-top: 0.5rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .audio-volume-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .audio-btn-volume {
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.7);
        font-size: 1.1rem;
        cursor: pointer;
        padding: 0.25rem;
    }

    .audio-btn-volume:hover {
        color: #e94560;
    }

    .audio-volume-slider {
        width: 80px;
        height: 4px;
        -webkit-appearance: none;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        cursor: pointer;
    }

    .audio-volume-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 12px;
        height: 12px;
        background: #e94560;
        border-radius: 50%;
        cursor: pointer;
    }

    .audio-extra-controls {
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

    .audio-btn-extra {
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.5);
        font-size: 1rem;
        cursor: pointer;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        transition: all 0.2s ease;
    }

    .audio-btn-extra:hover {
        color: #e94560;
        background: rgba(233, 69, 96, 0.1);
    }

    .audio-btn-extra.active {
        color: #e94560;
    }

    /* Playlist Styles */
    .playlist-section {
        margin-top: 1rem;
    }

    .audio-playlist {
        max-height: 220px;
        overflow-y: auto;
        border-radius: 0.5rem;
        background: rgba(0, 0, 0, 0.2);
    }

    /* Expanded mode - show more tracks */
    .audio-player-content.expanded {
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    .audio-player-content.expanded .playlist-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
    }

    .audio-player-content.expanded .audio-playlist {
        flex: 1;
        max-height: none !important;
        overflow-y: auto;
    }

    .audio-playlist::-webkit-scrollbar {
        width: 6px;
    }

    .audio-playlist::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
    }

    .audio-playlist::-webkit-scrollbar-thumb {
        background: rgba(233, 69, 96, 0.5);
        border-radius: 3px;
    }

    .playlist-item {
        display: flex;
        align-items: center;
        padding: 0.625rem 0.75rem;
        cursor: pointer;
        transition: all 0.2s ease;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        gap: 0.5rem;
        user-select: none;
    }

    .playlist-item:last-child {
        border-bottom: none;
    }

    .playlist-item:hover {
        background: rgba(233, 69, 96, 0.1);
    }

    .playlist-item.active {
        background: rgba(233, 69, 96, 0.2);
    }

    .playlist-item.dragging {
        opacity: 0.5;
        background: rgba(233, 69, 96, 0.3);
    }

    .playlist-item.drag-over {
        border-top: 2px solid #e94560;
        margin-top: -2px;
    }

    .playlist-item-drag-handle {
        color: rgba(255, 255, 255, 0.3);
        font-size: 0.875rem;
        cursor: grab;
        padding: 0.25rem;
        transition: color 0.2s ease;
    }

    .playlist-item-drag-handle:active {
        cursor: grabbing;
    }

    .playlist-item:hover .playlist-item-drag-handle {
        color: rgba(255, 255, 255, 0.6);
    }

    .playlist-item-index {
        color: rgba(255, 255, 255, 0.4);
        font-size: 0.75rem;
        width: 22px;
        text-align: center;
    }

    .playlist-item.active .playlist-item-index {
        color: #e94560;
    }

    .playlist-item-icon {
        color: #e94560;
        font-size: 0.9rem;
    }

    .playlist-item-title {
        flex: 1;
        color: rgba(255, 255, 255, 0.8);
        font-size: 0.875rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .playlist-item.active .playlist-item-title {
        color: #fff;
        font-weight: 500;
    }

    .playlist-item-actions {
        display: flex;
        gap: 0.25rem;
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .playlist-item:hover .playlist-item-actions {
        opacity: 1;
    }

    /* Always show on mobile */
    @@media (max-width: 768px) {
        .playlist-item-actions {
            opacity: 1;
        }
    }

    .playlist-item-btn {
        color: rgba(255, 255, 255, 0.5);
        background: none;
        border: none;
        padding: 0.25rem;
        cursor: pointer;
        border-radius: 4px;
        transition: all 0.2s ease;
    }

    .playlist-item-btn:hover {
        color: #e94560;
        background: rgba(233, 69, 96, 0.1);
    }

    .playlist-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
        padding: 0 0.25rem;
    }

    .playlist-header-title {
        color: rgba(255, 255, 255, 0.6);
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .playlist-header-count {
        color: rgba(255, 255, 255, 0.9);
        font-size: 0.7rem;
        background: rgba(233, 69, 96, 0.3);
        padding: 0.15rem 0.5rem;
        border-radius: 10px;
        font-weight: 500;
        min-width: 1.5rem;
        text-align: center;
    }

    /* Track options dropdown */
    .track-options-dropdown {
        position: absolute;
        background: #1a1a2e;
        border: 1px solid rgba(233, 69, 96, 0.3);
        border-radius: 0.5rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        z-index: 100;
        min-width: 180px;
        overflow: hidden;
    }

    .track-options-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        color: rgba(255, 255, 255, 0.8);
        cursor: pointer;
        transition: all 0.2s;
        border: none;
        background: none;
        width: 100%;
        text-align: left;
        font-size: 0.875rem;
    }

    .track-options-item:hover {
        background: rgba(233, 69, 96, 0.2);
        color: white;
    }

    .track-options-item i {
        width: 18px;
        color: #e94560;
    }

    /* Mobile Fullscreen Styles */
    @@media (max-width: 768px) {
        .audio-player-container {
            max-width: 100%;
            max-height: 100%;
            height: 100%;
            margin: 0;
            border-radius: 0;
            flex-direction: column;
        }

        .audio-player-sidebar {
            display: none !important;
        }

        .audio-player-main {
            height: 100%;
            max-height: 100%;
            overflow: hidden;
        }

        .audio-player-content {
            padding: 1rem;
            padding-top: 3rem;
            height: 100%;
            max-height: 100%;
            box-sizing: border-box;
        }

        /* Avoid overlap with close button */
        .current-playlist-badge {
            margin-right: 3rem;
            max-width: calc(100% - 3.5rem);
        }

        .album-art {
            width: 180px;
            height: 180px;
        }

        .album-art::before {
            width: 32px;
            height: 32px;
        }

        .album-art i {
            font-size: 4rem;
        }

        .audio-title-display {
            font-size: 1rem;
        }

        .audio-visualizer {
            height: 70px;
        }

        .audio-btn-play {
            width: 64px;
            height: 64px;
            font-size: 1.75rem;
        }

        .audio-btn-nav {
            width: 44px;
            height: 44px;
            font-size: 1.25rem;
        }

        .audio-playlist {
            max-height: 35vh;
            padding-bottom: 1rem;
        }

        .audio-volume-container {
            display: none;
        }
    }

    /* Very small screens */
    @@media (max-width: 400px) {
        .album-art {
            width: 140px;
            height: 140px;
        }

        .album-art i {
            font-size: 3rem;
        }
    }

    /* Queue header with compact buttons */
    .queue-header-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
    }

    .queue-header-actions {
        display: flex;
        gap: 0.25rem;
    }

    .queue-btn {
        width: 28px;
        height: 28px;
        padding: 0;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 50%;
        color: rgba(255, 255, 255, 0.6);
        font-size: 0.8rem;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .queue-btn:hover:not(:disabled) {
        background: rgba(233, 69, 96, 0.3);
        color: white;
    }

    .queue-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

    .queue-btn.active {
        background: rgba(233, 69, 96, 0.4);
        color: #e94560;
    }

    /* Expanded playlist mode */
    .audio-player-content.expanded .album-art,
    .audio-player-content.expanded .audio-title-display,
    .audio-player-content.expanded .audio-visualizer,
    .audio-player-content.expanded .audio-loading-indicator,
    .audio-player-content.expanded .current-playlist-badge {
        display: none;
    }

    .audio-player-content.expanded .audio-controls {
        padding: 0.75rem;
    }

    .audio-player-content.expanded .audio-main-controls {
        margin-bottom: 0.25rem;
    }

    .audio-player-content.expanded .audio-secondary-controls {
        padding-top: 0.25rem;
    }

    .audio-player-content.expanded .playlist-section {
        margin-top: 0.5rem;
    }

    @@media (min-width: 769px) {
        .audio-player-content.expanded {
            overflow: hidden;
            padding: 0.75rem;
        }

        .audio-player-content.expanded .compact-now-playing {
            padding: 0.35rem 0.5rem;
            margin-bottom: 0.35rem;
        }

        .audio-player-content.expanded .audio-controls {
            padding: 0.5rem;
        }

        .audio-player-content.expanded .playlist-section {
            display: flex;
            flex-direction: column;
            margin-top: 0.25rem;
        }

        .audio-player-content.expanded .queue-header-row {
            flex-shrink: 0;
            padding-bottom: 0.25rem;
        }

        .audio-player-content.expanded .audio-playlist {
            flex: 1;
            min-height: 0;
            max-height: calc(90vh - 200px);
            overflow-y: auto;
        }

        .audio-player-content.expanded .playlist-item {
            padding: 0.4rem 0.5rem;
        }
    }

    @@media (max-width: 768px) {
        .audio-player-content.expanded {
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .audio-player-content.expanded .compact-now-playing {
            flex: 0 0 auto;
        }

        .audio-player-content.expanded .audio-controls {
            flex: 0 0 auto;
        }

        .audio-player-content.expanded .playlist-section {
            flex: 1 1 0;
            min-height: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .audio-player-content.expanded .queue-header-row {
            flex: 0 0 auto;
            margin-bottom: 0.5rem;
        }

        .audio-player-content.expanded .audio-playlist {
            flex: 1 1 0;
            min-height: 0;
            max-height: none;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 1rem;
        }
    }

    /* Compact now playing bar in expanded mode */
    .compact-now-playing {
        display: none;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 0.5rem;
        padding: 0.5rem 0.75rem;
        margin-bottom: 0.5rem;
        align-items: center;
        gap: 0.5rem;
    }

    .audio-player-content.expanded .compact-now-playing {
        display: flex;
    }

    .compact-now-playing-icon {
        width: 32px;
        height: 32px;
        background: linear-gradient(135deg, #e94560 0%, #0f3460 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 0.8rem;
        flex-shrink: 0;
    }

    .compact-now-playing-info {
        flex: 1;
        min-width: 0;
    }

    .compact-now-playing-title {
        color: white;
        font-size: 0.8rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .compact-now-playing-time {
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.7rem;
    }

    /* Track Info Modal */
    .track-info-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1100;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s ease;
    }

    .track-info-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    .track-info-modal {
        width: 90%;
        max-width: 400px;
        max-height: 80vh;
        background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
        border-radius: 1rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        overflow: hidden;
        transform: scale(0.9);
        transition: transform 0.2s ease;
    }

    .track-info-overlay.show .track-info-modal {
        transform: scale(1);
    }

    .track-info-header {
        padding: 1rem;
        background: rgba(233, 69, 96, 0.15);
        border-bottom: 1px solid rgba(233, 69, 96, 0.2);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .track-info-header h4 {
        margin: 0;
        color: white;
        font-size: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .track-info-header h4 i {
        color: #e94560;
    }

    .track-info-close {
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.6);
        font-size: 1.25rem;
        cursor: pointer;
        padding: 0.25rem;
    }

    .track-info-close:hover {
        color: white;
    }

    .track-info-content {
        padding: 1rem;
        overflow-y: auto;
        max-height: calc(80vh - 60px);
    }

    .track-info-title {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 0.5rem;
        padding: 0.75rem;
        margin-bottom: 1rem;
        color: white;
        font-weight: 500;
        word-break: break-word;
    }

    .track-info-row {
        display: flex;
        padding: 0.5rem 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .track-info-row:last-child {
        border-bottom: none;
    }

    .track-info-label {
        width: 100px;
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.8rem;
        flex-shrink: 0;
    }

    .track-info-value {
        flex: 1;
        color: white;
        font-size: 0.85rem;
        word-break: break-word;
    }

    .track-info-value.highlight {
        color: #e94560;
    }

    .track-info-playlists {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .track-info-playlists-title {
        color: rgba(255, 255, 255, 0.6);
        font-size: 0.75rem;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
    }

    .track-info-playlist-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 0.375rem;
        margin-bottom: 0.25rem;
        color: rgba(255, 255, 255, 0.8);
        font-size: 0.8rem;
    }

    .track-info-playlist-item i {
        color: #e94560;
    }
</style>

<div class="audio-player-overlay @(isVisible ? "show" : "")" @onclick="OnOverlayClick">
    <div class="audio-player-container" @onclick:stopPropagation="true">
        <!-- Main Player Section -->
        <div class="audio-player-main">
            <button class="audio-close-btn" @onclick="OnHideModalClick">
                <i class="bi bi-x-lg"></i>
            </button>

            <div class="audio-player-content @(isPlaylistExpanded ? "expanded" : "")">
                @if (!string.IsNullOrEmpty(currentPlaylistName))
                {
                    <div class="current-playlist-badge">
                        <i class="bi bi-music-note-list"></i>
                        <span>@currentPlaylistName</span>
                    </div>
                }

                <div class="album-art @(isPlaying ? "playing" : "")">
                    @if (!string.IsNullOrEmpty(artworkUrl))
                    {
                        <img src="@artworkUrl" alt="Album Art" class="album-art-image" />
                    }
                    else
                    {
                        <i class="bi bi-music-note-beamed"></i>
                    }
                </div>

                @if (!string.IsNullOrEmpty(audioTitle))
                {
                    <div class="audio-title-display">
                        <i class="bi bi-file-earmark-music"></i>
                        <div class="title-wrapper">
                            <span class="title-text @(audioTitle.Length > 30 ? "scrolling" : "")"
                                  title="@audioTitle"
                                  data-text="@audioTitle">@audioTitle</span>
                        </div>
                    </div>
                }

                @if (isInitialLoading || isBuffering)
                {
                    <div class="audio-loading-indicator">
                        <div class="loading-spinner"></div>
                        <span class="loading-text">@loadingStatus</span>
                        @if (bufferPercent > 0 && bufferPercent < 100)
                        {
                            <div class="loading-progress">
                                <div class="loading-progress-bar" style="width: @(bufferPercent.ToString("F0", System.Globalization.CultureInfo.InvariantCulture))%"></div>
                            </div>
                            <span class="loading-percent">@bufferPercent.ToString("F0")%</span>
                        }
                    </div>
                }
                else if (enableVisualizer)
                {
                    <div class="audio-visualizer @(isPlaying ? "" : "paused") @(useRealVisualizer ? "real-time" : "")">
                        @for (int i = 0; i < 13; i++)
                        {
                            var height = useRealVisualizer && visualizerBars != null && i < visualizerBars.Length
                                ? visualizerBars[i]
                                : GetDefaultBarHeight(i);
                            <div class="bar" style="@(useRealVisualizer ? $"height: {height.ToString("F0", System.Globalization.CultureInfo.InvariantCulture)}%" : "")"></div>
                        }
                    </div>
                }

                <div class="audio-controls">
                    <div class="audio-main-controls">
                        <button class="audio-btn-repeat @(repeatMode != RepeatMode.None ? "active" : "")" @onclick="ToggleRepeatMode" title="@GetRepeatModeTitle()">
                            <i class="bi @GetRepeatModeIcon()"></i>
                            @if (repeatMode == RepeatMode.One)
                            {
                                <span class="repeat-badge">1</span>
                            }
                        </button>
                        <button class="audio-btn-nav" @onclick="PlayPrevious" disabled="@(!CanPlayPrevious)">
                            <i class="bi bi-skip-backward-fill"></i>
                        </button>
                        <button class="audio-btn-play" @onclick="TogglePlayPause">
                            <i class="bi @(isPlaying ? "bi-pause-fill" : "bi-play-fill")"></i>
                        </button>
                        <button class="audio-btn-nav" @onclick="PlayNext" disabled="@(!CanPlayNext && repeatMode != RepeatMode.All)">
                            <i class="bi bi-skip-forward-fill"></i>
                        </button>
                        <button class="audio-btn-extra" @onclick="SaveCurrentToPlaylist" disabled="@string.IsNullOrEmpty(audioUrl)" title="Add to playlist">
                            <i class="bi bi-plus-circle"></i>
                        </button>
                    </div>

                    <div class="audio-controls-row">
                        <div class="audio-progress-container">
                            <input type="range" class="audio-seek-slider" min="0" max="100" step="0.1"
                                   value="@progressPercent.ToString("F1", System.Globalization.CultureInfo.InvariantCulture)"
                                   style="background: linear-gradient(to right, #e94560 0%, #e94560 @(progressPercent.ToString("F1", System.Globalization.CultureInfo.InvariantCulture))%, rgba(255,255,255,0.1) @(progressPercent.ToString("F1", System.Globalization.CultureInfo.InvariantCulture))%, rgba(255,255,255,0.1) 100%);"
                                   @oninput="SeekAudioInput"
                                   @onchange="SeekAudioChange" />
                            <div class="audio-time">
                                <span>@currentTimeDisplay</span>
                                <span>@durationDisplay</span>
                            </div>
                        </div>
                    </div>

                    <div class="audio-secondary-controls">
                        <div class="audio-volume-container">
                            <button class="audio-btn-volume" @onclick="ToggleMute">
                                <i class="bi @(isMuted ? "bi-volume-mute-fill" : "bi-volume-up-fill")"></i>
                            </button>
                            <input type="range" class="audio-volume-slider" min="0" max="100" value="@volume"
                                   style="background: linear-gradient(to right, #e94560 0%, #e94560 @(volume)%, rgba(255,255,255,0.1) @(volume)%, rgba(255,255,255,0.1) 100%);"
                                   @oninput="ChangeVolumeInput"
                                   @onchange="ChangeVolume" />
                        </div>
                        <div class="audio-extra-controls">
                            <button class="audio-btn-extra @(enableVisualizer ? "active" : "")" @onclick="ToggleVisualizer" title="@(enableVisualizer ? "Disable visualizer" : "Enable visualizer")">
                                <i class="bi @(enableVisualizer ? "bi-soundwave" : "bi-slash-circle")"></i>
                            </button>
                            <button class="audio-btn-extra" @onclick="OpenPlaylistManager" title="Manage playlists">
                                <i class="bi bi-collection"></i>
                            </button>
                        </div>
                    </div>
                </div>

                @* Compact now playing bar (shown in expanded mode) *@
                <div class="compact-now-playing">
                    <div class="compact-now-playing-icon">
                        <i class="bi @(isPlaying ? "bi-volume-up-fill" : "bi-music-note")"></i>
                    </div>
                    <div class="compact-now-playing-info">
                        <div class="compact-now-playing-title">@audioTitle</div>
                        <div class="compact-now-playing-time">@currentTimeDisplay / @durationDisplay</div>
                    </div>
                </div>

                @if (playlist.Count > 0)
                {
                    <div class="playlist-section">
                        <div class="queue-header-row">
                            <div class="playlist-header" style="margin-bottom: 0;">
                                <span class="playlist-header-title">Queue</span>
                                <span class="playlist-header-count">@playlist.Count</span>
                            </div>
                            <div class="queue-header-actions">
                                <button class="queue-btn @(isPlaylistExpanded ? "active" : "")"
                                        @onclick="TogglePlaylistExpanded"
                                        title="@(isPlaylistExpanded ? "Collapse" : "Expand playlist")">
                                    <i class="bi @(isPlaylistExpanded ? "bi-arrows-angle-contract" : "bi-arrows-angle-expand")"></i>
                                </button>
                                <button class="queue-btn" @onclick="SaveQueueToCurrentPlaylist"
                                        disabled="@(string.IsNullOrEmpty(currentPlaylistId) || playlist.Count == 0)"
                                        title="Save to current playlist">
                                    <i class="bi bi-save"></i>
                                </button>
                                <button class="queue-btn" @onclick="SaveQueueToOtherPlaylist"
                                        disabled="@(playlist.Count == 0)"
                                        title="Save to other playlist">
                                    <i class="bi bi-folder-plus"></i>
                                </button>
                            </div>
                        </div>
                        <div class="audio-playlist">
                            @for (int i = 0; i < playlist.Count; i++)
                            {
                                var index = i;
                                var item = playlist[i];
                                <div class="playlist-item @(index == currentTrackIndex ? "active" : "") @(draggedIndex == index ? "dragging" : "") @(dragOverIndex == index ? "drag-over" : "")"
                                     draggable="true"
                                     @ondragstart="() => OnDragStart(index)"
                                     @ondragover:preventDefault="true"
                                     @ondragover="() => OnDragOver(index)"
                                     @ondragleave="OnDragLeave"
                                     @ondrop="() => OnDrop(index)"
                                     @ondragend="OnDragEnd"
                                     @onclick="() => PlayTrack(index)">
                                    <span class="playlist-item-drag-handle" @onclick:stopPropagation="true">
                                        <i class="bi bi-grip-vertical"></i>
                                    </span>
                                    <span class="playlist-item-index">@(index + 1)</span>
                                    @if (index == currentTrackIndex && isPlaying)
                                    {
                                        <i class="bi bi-volume-up-fill playlist-item-icon"></i>
                                    }
                                    else
                                    {
                                        <i class="bi bi-music-note playlist-item-icon"></i>
                                    }
                                    <span class="playlist-item-title" title="@item.Title">@item.Title</span>
                                    <div class="playlist-item-actions">
                                        <button class="playlist-item-btn" @onclick="() => ShowTrackInfo(index)" @onclick:stopPropagation="true" title="Track info">
                                            <i class="bi bi-info-circle"></i>
                                        </button>
                                        <button class="playlist-item-btn" @onclick="() => SaveTrackToPlaylist(index)" @onclick:stopPropagation="true" title="Add to playlist">
                                            <i class="bi bi-plus-circle"></i>
                                        </button>
                                        <button class="playlist-item-btn" @onclick="() => RemoveFromPlaylist(index)" @onclick:stopPropagation="true" title="Remove">
                                            <i class="bi bi-x"></i>
                                        </button>
                                    </div>
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>
        </div>

        <!-- Saved Playlists Sidebar - Desktop only -->
        <div class="audio-player-sidebar">
            <div class="sidebar-header">
                <i class="bi bi-music-note-list"></i>
                <span>My Playlists</span>
            </div>
            <div class="saved-playlists-list">
                @if (savedPlaylists != null && savedPlaylists.Count > 0)
                {
                    @foreach (var pl in savedPlaylists)
                    {
                        <div class="saved-playlist-item @(currentPlaylistId == pl.Id ? "active" : "")" @onclick="() => OpenPlaylistForEditing(pl.Id)">
                            <div class="saved-playlist-icon">
                                <i class="bi bi-music-note-list"></i>
                            </div>
                            <div class="saved-playlist-info">
                                <div class="saved-playlist-name">@pl.Name</div>
                                <div class="saved-playlist-count">@pl.TrackCount tracks</div>
                            </div>
                            <button class="saved-playlist-play" @onclick:stopPropagation="true" @onclick="() => PlaySavedPlaylist(pl)">
                                <i class="bi bi-play-fill"></i>
                            </button>
                        </div>
                    }
                }
                else
                {
                    <div style="padding: 1rem; color: rgba(255,255,255,0.5); text-align: center; font-size: 0.85rem;">
                        No playlists yet
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@* Audio element persistente fuera del modal *@
<audio id="audioPlayer"
       style="display: none;"
       @onplay="OnPlay"
       @onpause="OnPause"
       @onended="OnEnded"
       @onwaiting="OnWaiting"
       @oncanplay="OnCanPlay"
       @onloadstart="OnLoadStart">
</audio>

@* Track Info Modal *@
<div class="track-info-overlay @(showTrackInfo ? "show" : "")" @onclick="CloseTrackInfo">
    <div class="track-info-modal" @onclick:stopPropagation="true">
        <div class="track-info-header">
            <h4><i class="bi bi-info-circle"></i> Track Info</h4>
            <button class="track-info-close" @onclick="CloseTrackInfo">
                <i class="bi bi-x-lg"></i>
            </button>
        </div>
        @if (trackInfoData != null)
        {
            <div class="track-info-content">
                <div class="track-info-title">
                    <i class="bi bi-music-note me-2" style="color: #e94560;"></i>
                    @trackInfoData.Title
                </div>

                <div class="track-info-row">
                    <span class="track-info-label">Source</span>
                    <span class="track-info-value @(trackInfoData.IsLocal ? "" : "highlight")">
                        @(trackInfoData.IsLocal ? "Local File" : trackInfoData.ChannelName)
                    </span>
                </div>

                <div class="track-info-row">
                    <span class="track-info-label">Type</span>
                    <span class="track-info-value">@trackInfoData.FileType.ToUpperInvariant()</span>
                </div>

                <div class="track-info-row">
                    <span class="track-info-label">Position</span>
                    <span class="track-info-value">@(trackInfoData.QueuePosition + 1) of @playlist.Count</span>
                </div>

                @if (!string.IsNullOrEmpty(trackInfoData.Duration))
                {
                    <div class="track-info-row">
                        <span class="track-info-label">Duration</span>
                        <span class="track-info-value">@trackInfoData.Duration</span>
                    </div>
                }

                @if (trackInfoData.FileSize > 0)
                {
                    <div class="track-info-row">
                        <span class="track-info-label">Size</span>
                        <span class="track-info-value">@FormatFileSize(trackInfoData.FileSize)</span>
                    </div>
                }

                @if (!string.IsNullOrEmpty(currentPlaylistName))
                {
                    <div class="track-info-row">
                        <span class="track-info-label">Playing from</span>
                        <span class="track-info-value highlight">@currentPlaylistName</span>
                    </div>
                }

                @if (trackInfoData.ContainedInPlaylists?.Count > 0)
                {
                    <div class="track-info-playlists">
                        <div class="track-info-playlists-title">Also in playlists</div>
                        @foreach (var plName in trackInfoData.ContainedInPlaylists)
                        {
                            <div class="track-info-playlist-item">
                                <i class="bi bi-music-note-list"></i>
                                <span>@plName</span>
                            </div>
                        }
                    </div>
                }
            </div>
        }
    </div>
</div>

@code {
    private bool isVisible = false;
    private string audioUrl = "";
    private string audioType = "audio/mpeg";
    private string audioTitle = "";
    private bool isPlaying = false;
    private bool isMuted = false;
    private int volume = 100;
    private double progressPercent = 0;
    private double bufferPercent = 0;
    private string currentTimeDisplay = "0:00";
    private string durationDisplay = "0:00";
    private CancellationTokenSource? progressCts;

    // Album artwork
    private string? artworkUrl = null;
#pragma warning disable CS0414
    private bool isLoadingArtwork = false;
#pragma warning restore CS0414

    // Loading/Buffering state
    private bool isBuffering = false;
    private bool isInitialLoading = false;
    private string loadingStatus = "";

    // Real-time visualizer
    private bool useRealVisualizer = false;
    private bool enableVisualizer = true;
    private double[] visualizerBars = new double[13];
    private CancellationTokenSource? visualizerCts;

    // Playlist
    private List<PlaylistItem> playlist = new();
    private int currentTrackIndex = -1;

    // Repeat mode
    private RepeatMode repeatMode = RepeatMode.None;

    // Current saved playlist info
    private string? currentPlaylistId = null;
    private string? currentPlaylistName = null;

    // Saved playlists for sidebar
    private List<Models.PlaylistModel>? savedPlaylists = null;

    // Drag and drop state
    private int? draggedIndex = null;
    private int? dragOverIndex = null;

    // Playlist expanded mode
    private bool isPlaylistExpanded = false;

    // Track info modal
    private bool showTrackInfo = false;
    private TrackInfoData? trackInfoData = null;

    // Disposed state
    private bool _disposed = false;

    // DotNet reference for JS interop
    private DotNetObjectReference<AudioPlayerModal>? _dotNetRef;

    public class TrackInfoData
    {
        public string Title { get; set; } = "";
        public string Url { get; set; } = "";
        public string FileType { get; set; } = "";
        public string ChannelName { get; set; } = "";
        public string ChannelId { get; set; } = "";
        public string FileId { get; set; } = "";
        public long FileSize { get; set; }
        public string? Duration { get; set; }
        public bool IsLocal { get; set; }
        public int QueuePosition { get; set; }
        public List<string>? ContainedInPlaylists { get; set; }
    }

    public enum RepeatMode
    {
        None = 0,
        All = 1,
        One = 2
    }

    public class PlaylistItem
    {
        public string Url { get; set; } = "";
        public string Type { get; set; } = "audio/mpeg";
        public string Title { get; set; } = "";
    }

    private bool CanPlayPrevious => currentTrackIndex > 0 || repeatMode == RepeatMode.All;
    private bool CanPlayNext => currentTrackIndex < playlist.Count - 1 || repeatMode == RepeatMode.All;

    private string GetRepeatModeIcon() => repeatMode switch
    {
        RepeatMode.One => "bi-repeat-1",
        _ => "bi-repeat"
    };

    private string GetRepeatModeTitle() => repeatMode switch
    {
        RepeatMode.None => "Repeat: Off",
        RepeatMode.All => "Repeat: All",
        RepeatMode.One => "Repeat: One",
        _ => "Repeat"
    };

    private void ToggleRepeatMode()
    {
        repeatMode = repeatMode switch
        {
            RepeatMode.None => RepeatMode.All,
            RepeatMode.All => RepeatMode.One,
            RepeatMode.One => RepeatMode.None,
            _ => RepeatMode.None
        };
        StateHasChanged();
    }

    private void TogglePlaylistExpanded()
    {
        isPlaylistExpanded = !isPlaylistExpanded;
        StateHasChanged();
    }

    public async Task ShowModal(string url, string type = "audio/mpeg", string title = "")
    {
        if (_disposed) return;
        try
        {
            bool isSameTrack = audioUrl == url;

            audioUrl = url;
            audioType = string.IsNullOrEmpty(type) ? "audio/mpeg" : type;
            audioTitle = !string.IsNullOrEmpty(title) ? title : ExtractFileName(url);

            var existingIndex = playlist.FindIndex(p => p.Url == url);
            if (existingIndex < 0)
            {
                playlist.Add(new PlaylistItem { Url = url, Type = audioType, Title = audioTitle });
                currentTrackIndex = playlist.Count - 1;
            }
            else
            {
                currentTrackIndex = existingIndex;
            }

            // Always set visible and update UI first
            isVisible = true;
            try { await LoadSavedPlaylists(); } catch { /* Don't block showing the modal */ }
            await InvokeAsync(StateHasChanged);
            await Task.Delay(100);

            if (!isSameTrack)
            {
                isPlaying = false;
                progressPercent = 0;
                bufferPercent = 0;
                currentTimeDisplay = "0:00";
                artworkUrl = null;

                bool isTelegramFile = audioUrl.Contains("/api/file/") || audioUrl.Contains("GetFileStream");
                isInitialLoading = isTelegramFile;
                isBuffering = false;
                loadingStatus = isTelegramFile ? "Loading from Telegram..." : "";

                try
                {
                    await JSRuntime.InvokeVoidAsync("playAudioPlayer", audioUrl, audioType);
                }
                catch { /* Continue showing modal even if playback fails */ }
                _ = ExtractArtworkAndUpdateMediaSession(audioUrl);
            }

            StartProgressTimer();
            try { await UpdateProgress(); } catch { }
        }
        catch
        {
            // If we got here and isVisible was set, ensure UI still updates
            if (isVisible)
            {
                try { await InvokeAsync(StateHasChanged); } catch { }
            }
        }
    }

    public async Task ShowCurrentModal()
    {
        if (_disposed) return;
        try
        {
            isVisible = true;
            try { await LoadSavedPlaylists(); } catch { /* Don't block showing the modal */ }
            await InvokeAsync(StateHasChanged);
            await Task.Delay(100);

            if (!string.IsNullOrEmpty(audioUrl))
            {
                StartProgressTimer();
                try { await UpdateProgress(); } catch { }
            }
        }
        catch
        {
            // Ensure UI updates if we got here with isVisible set
            if (isVisible)
            {
                try { await InvokeAsync(StateHasChanged); } catch { }
            }
        }
    }

    private async Task LoadSavedPlaylists()
    {
        try
        {
            savedPlaylists = await DbService.GetAllPlaylists();
        }
        catch
        {
            savedPlaylists = new List<Models.PlaylistModel>();
        }
    }

    private async Task LoadSavedPlaylist(Models.PlaylistModel pl)
    {
        // Load the playlist tracks into the queue (without playing)
        try
        {
            currentPlaylistId = pl.Id;
            currentPlaylistName = pl.Name;

            playlist.Clear();
            foreach (var track in pl.Tracks.OrderBy(t => t.Order))
            {
                var url = track.IsLocalFile ? track.DirectUrl! : GetTrackUrl(track);
                playlist.Add(new PlaylistItem
                {
                    Url = url,
                    Type = track.FileType,
                    Title = track.FileName
                });
            }

            currentTrackIndex = -1; // No track selected yet
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private async Task PlaySavedPlaylist(Models.PlaylistModel pl)
    {
        try
        {
            currentPlaylistId = pl.Id;
            currentPlaylistName = pl.Name;

            playlist.Clear();
            foreach (var track in pl.Tracks.OrderBy(t => t.Order))
            {
                var url = track.IsLocalFile ? track.DirectUrl! : GetTrackUrl(track);
                playlist.Add(new PlaylistItem
                {
                    Url = url,
                    Type = track.FileType,
                    Title = track.FileName
                });
            }

            if (playlist.Count > 0)
            {
                await PlayTrack(0);
            }

            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private void OpenPlaylistForEditing(string playlistId)
    {
        // Open the PlaylistManagerModal with this playlist selected for editing
        TelegramDownloader.Shared.MainLayout.OpenPlaylistManagerWithPlaylist(playlistId);
    }

    private string GetTrackUrl(Models.PlaylistTrackModel track)
    {
        return $"/api/file/GetFileByTfmId/{track.FileName}?idChannel={track.ChannelId}&idFile={track.FileId}";
    }

    public async Task OnHideModalClick()
    {
        try
        {
            StopProgressTimer();
            await JSRuntime.InvokeVoidAsync("closeAudioModal");
            isVisible = false;
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private async Task OnOverlayClick()
    {
        await OnHideModalClick();
    }

    private async Task TogglePlayPause()
    {
        if (isPlaying)
        {
            await JSRuntime.InvokeVoidAsync("pauseAudioPlayer");
            await UpdateMediaSessionPlaybackState("paused");
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("resumeAudioPlayer");
            await UpdateMediaSessionPlaybackState("playing");
        }
    }

    private async Task SeekAudioInput(Microsoft.AspNetCore.Components.ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out double percent))
        {
            progressPercent = percent;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SeekAudioChange(Microsoft.AspNetCore.Components.ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out double percent))
        {
            if (percent < 0) percent = 0;
            if (percent > 100) percent = 100;
            await JSRuntime.InvokeVoidAsync("seekAudioPlayer", percent);
            await UpdateProgress();
        }
    }

    private async Task ChangeVolumeInput(Microsoft.AspNetCore.Components.ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int newVolume))
        {
            volume = newVolume;
            isMuted = volume == 0;
            await JSRuntime.InvokeVoidAsync("setAudioVolume", volume / 100.0);
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ChangeVolume(Microsoft.AspNetCore.Components.ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int newVolume))
        {
            volume = newVolume;
            isMuted = volume == 0;
            await JSRuntime.InvokeVoidAsync("setAudioVolume", volume / 100.0);
        }
    }

    private async Task ToggleMute()
    {
        isMuted = !isMuted;
        await JSRuntime.InvokeVoidAsync("setAudioMuted", isMuted);
        StateHasChanged();
    }

    private void StartProgressTimer()
    {
        StopProgressTimer();
        progressCts = new CancellationTokenSource();
        _ = UpdateProgressLoop(progressCts.Token);
    }

    private async Task UpdateProgressLoop(CancellationToken token)
    {
        while (!token.IsCancellationRequested && !_disposed)
        {
            try
            {
                if (_disposed) break;
                await UpdateProgress();
                if (_disposed) break;
                await InvokeAsync(StateHasChanged);
                await Task.Delay(500, token);
            }
            catch (TaskCanceledException) { break; }
            catch (ObjectDisposedException) { break; }
            catch { }
        }
    }

    private void StopProgressTimer()
    {
        progressCts?.Cancel();
        progressCts?.Dispose();
        progressCts = null;
    }

    private async Task UpdateProgress()
    {
        try
        {
            var audioInfo = await JSRuntime.InvokeAsync<AudioInfo>("getAudioInfo");
            if (audioInfo != null)
            {
                var wasPlaying = isPlaying;
                isPlaying = audioInfo.IsPlaying;
                progressPercent = audioInfo.Progress;
                bufferPercent = audioInfo.BufferPercent;
                currentTimeDisplay = FormatTime(audioInfo.CurrentTime);
                durationDisplay = FormatTime(audioInfo.Duration);

                if (audioInfo.Duration > 0)
                {
                    await UpdateMediaSessionPosition(audioInfo.Duration, audioInfo.CurrentTime);
                }

                if (wasPlaying != isPlaying)
                {
                    await UpdateMediaSessionPlaybackState(isPlaying ? "playing" : "paused");
                }
            }
        }
        catch { }
    }

    private string FormatTime(double seconds)
    {
        if (double.IsNaN(seconds) || double.IsInfinity(seconds)) return "0:00";
        var ts = TimeSpan.FromSeconds(seconds);
        return ts.Hours > 0
            ? $"{ts.Hours}:{ts.Minutes:D2}:{ts.Seconds:D2}"
            : $"{ts.Minutes}:{ts.Seconds:D2}";
    }

    public class AudioInfo
    {
        public bool IsPlaying { get; set; }
        public double CurrentTime { get; set; }
        public double Duration { get; set; }
        public double Progress { get; set; }
        public double BufferPercent { get; set; }
    }

    private async void OnPlay()
    {
        try
        {
            isPlaying = true;
            await StartRealVisualizer();
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private async void OnPause()
    {
        try
        {
            isPlaying = false;
            StopRealVisualizer();
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private int GetDefaultBarHeight(int index)
    {
        int[] defaultHeights = { 20, 40, 60, 80, 100, 80, 60, 40, 20, 40, 60, 80, 60 };
        return index < defaultHeights.Length ? defaultHeights[index] : 50;
    }

    private async Task StartRealVisualizer()
    {
        if (!enableVisualizer)
        {
            useRealVisualizer = false;
            return;
        }

        try
        {
            var initialized = await JSRuntime.InvokeAsync<bool>("initAudioVisualizer");
            if (initialized)
            {
                useRealVisualizer = true;
                visualizerCts?.Cancel();
                visualizerCts = new CancellationTokenSource();
                _ = UpdateVisualizerLoop(visualizerCts.Token);
            }
        }
        catch
        {
            useRealVisualizer = false;
        }
    }

    private async Task ToggleVisualizer()
    {
        enableVisualizer = !enableVisualizer;
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "audioPlayerVisualizerEnabled", enableVisualizer.ToString().ToLower());

        if (enableVisualizer && isPlaying)
        {
            await StartRealVisualizer();
        }
        else if (!enableVisualizer)
        {
            StopRealVisualizer();
            useRealVisualizer = false;
            await JSRuntime.InvokeVoidAsync("destroyAudioVisualizer");
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadVisualizerPreference()
    {
        try
        {
            var stored = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "audioPlayerVisualizerEnabled");
            if (!string.IsNullOrEmpty(stored))
            {
                enableVisualizer = stored.ToLower() == "true";
            }
        }
        catch
        {
            enableVisualizer = true;
        }
    }

    private void StopRealVisualizer()
    {
        visualizerCts?.Cancel();
        for (int i = 0; i < visualizerBars.Length; i++)
        {
            visualizerBars[i] = 5;
        }
    }

    private async Task UpdateVisualizerLoop(CancellationToken token)
    {
        while (!token.IsCancellationRequested && !_disposed && isPlaying)
        {
            try
            {
                var data = await JSRuntime.InvokeAsync<double[]>("getVisualizerData", token);
                if (data != null && data.Length >= 13)
                {
                    for (int i = 0; i < 13 && i < data.Length; i++)
                    {
                        visualizerBars[i] = Math.Max(5, data[i]);
                    }
                    await InvokeAsync(StateHasChanged);
                }
                await Task.Delay(50, token);
            }
            catch (TaskCanceledException) { break; }
            catch (ObjectDisposedException) { break; }
            catch { }
        }
    }

    private async void OnEnded()
    {
        try
        {
            isPlaying = false;

            if (repeatMode == RepeatMode.One)
            {
                // Repeat current track
                await PlayTrack(currentTrackIndex);
            }
            else if (CanPlayNext)
            {
                await PlayNext();
            }
            else if (repeatMode == RepeatMode.All && playlist.Count > 0)
            {
                // Loop back to first track
                await PlayTrack(0);
            }

            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private async void OnWaiting()
    {
        try
        {
            isBuffering = true;
            loadingStatus = "Buffering...";
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private async void OnCanPlay()
    {
        try
        {
            isBuffering = false;
            isInitialLoading = false;
            loadingStatus = "";
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private async void OnLoadStart()
    {
        try
        {
            bool isTelegramFile = audioUrl.Contains("/api/file/") || audioUrl.Contains("GetFileStream");
            if (isTelegramFile)
            {
                isInitialLoading = true;
                loadingStatus = "Loading from Telegram...";
                await InvokeAsync(StateHasChanged);
            }
        }
        catch { }
    }

    private void SaveCurrentToPlaylist()
    {
        if (string.IsNullOrEmpty(audioUrl)) return;

        var saveModal = MainLayout.GetSaveToPlaylistModal();
        if (saveModal != null)
        {
            bool isLocalFile = !audioUrl.Contains("/api/file/");

            var track = new Models.PlaylistTrackModel
            {
                FileId = isLocalFile ? "" : ExtractFileIdFromUrl(audioUrl),
                ChannelId = isLocalFile ? "" : ExtractChannelIdFromUrl(audioUrl),
                ChannelName = isLocalFile ? "Local" : "",
                FileName = audioTitle,
                FileType = ExtractFileTypeFromUrl(audioUrl),
                FileSize = 0,
                DirectUrl = isLocalFile ? audioUrl : null
            };

            _ = saveModal.Open(track);
        }
    }

    private void SaveTrackToPlaylist(int index)
    {
        if (index < 0 || index >= playlist.Count) return;

        var item = playlist[index];
        var saveModal = MainLayout.GetSaveToPlaylistModal();
        if (saveModal != null)
        {
            bool isLocalFile = !item.Url.Contains("/api/file/");

            var track = new Models.PlaylistTrackModel
            {
                FileId = isLocalFile ? "" : ExtractFileIdFromUrl(item.Url),
                ChannelId = isLocalFile ? "" : ExtractChannelIdFromUrl(item.Url),
                ChannelName = isLocalFile ? "Local" : "",
                FileName = item.Title,
                FileType = ExtractFileTypeFromUrl(item.Url),
                FileSize = 0,
                DirectUrl = isLocalFile ? item.Url : null
            };

            _ = saveModal.Open(track);
        }
    }

    private void OpenPlaylistManager()
    {
        MainLayout.OpenPlaylistManager();
    }

    /// <summary>
    /// Public method to refresh saved playlists in sidebar (call after adding tracks)
    /// </summary>
    public async Task RefreshSavedPlaylists()
    {
        await LoadSavedPlaylists();
        await InvokeAsync(StateHasChanged);
    }

    private async Task SaveQueueToCurrentPlaylist()
    {
        if (string.IsNullOrEmpty(currentPlaylistId) || playlist.Count == 0) return;

        try
        {
            var currentPl = savedPlaylists?.FirstOrDefault(p => p.Id == currentPlaylistId);
            if (currentPl == null) return;

            int addedCount = 0;
            foreach (var item in playlist)
            {
                bool isLocalFile = !item.Url.Contains("/api/file/");
                var fileId = isLocalFile ? "" : ExtractFileIdFromUrl(item.Url);

                // Check if track already exists in playlist
                bool alreadyExists = currentPl.Tracks.Any(t =>
                    (isLocalFile && t.DirectUrl == item.Url) ||
                    (!isLocalFile && t.FileId == fileId));

                if (!alreadyExists)
                {
                    var track = new Models.PlaylistTrackModel
                    {
                        FileId = fileId,
                        ChannelId = isLocalFile ? "" : ExtractChannelIdFromUrl(item.Url),
                        ChannelName = isLocalFile ? "Local" : "",
                        FileName = item.Title,
                        FileType = ExtractFileTypeFromUrl(item.Url),
                        FileSize = 0,
                        DirectUrl = isLocalFile ? item.Url : null,
                        Order = currentPl.Tracks.Count
                    };

                    await DbService.AddTrackToPlaylist(currentPlaylistId, track);
                    currentPl.Tracks.Add(track);
                    addedCount++;
                }
            }

            await RefreshSavedPlaylists();
        }
        catch { }
    }

    private void SaveQueueToOtherPlaylist()
    {
        if (playlist.Count == 0) return;

        // Create tracks from queue
        var tracks = playlist.Select(item =>
        {
            bool isLocalFile = !item.Url.Contains("/api/file/");
            return new Models.PlaylistTrackModel
            {
                FileId = isLocalFile ? "" : ExtractFileIdFromUrl(item.Url),
                ChannelId = isLocalFile ? "" : ExtractChannelIdFromUrl(item.Url),
                ChannelName = isLocalFile ? "Local" : "",
                FileName = item.Title,
                FileType = ExtractFileTypeFromUrl(item.Url),
                FileSize = 0,
                DirectUrl = isLocalFile ? item.Url : null
            };
        }).ToList();

        // Open the save modal with multiple tracks
        var saveModal = MainLayout.GetSaveToPlaylistModal();
        if (saveModal != null)
        {
            _ = saveModal.Open(tracks);
        }
    }

    private async Task ShowTrackInfo(int index)
    {
        if (index < 0 || index >= playlist.Count) return;

        var item = playlist[index];
        bool isLocalFile = !item.Url.Contains("/api/file/");

        // Get duration from audio element if this is the current track
        string? duration = null;
        if (index == currentTrackIndex && !string.IsNullOrEmpty(durationDisplay) && durationDisplay != "0:00")
        {
            duration = durationDisplay;
        }

        // Find which playlists contain this track
        var containedIn = new List<string>();
        if (savedPlaylists != null)
        {
            var fileId = isLocalFile ? "" : ExtractFileIdFromUrl(item.Url);
            foreach (var pl in savedPlaylists)
            {
                bool found = pl.Tracks.Any(t =>
                    (isLocalFile && t.DirectUrl == item.Url) ||
                    (!isLocalFile && !string.IsNullOrEmpty(fileId) && t.FileId == fileId) ||
                    t.FileName == item.Title);

                if (found && pl.Name != currentPlaylistName)
                {
                    containedIn.Add(pl.Name);
                }
            }
        }

        trackInfoData = new TrackInfoData
        {
            Title = item.Title,
            Url = item.Url,
            FileType = ExtractFileTypeFromUrl(item.Url).TrimStart('.'),
            ChannelName = isLocalFile ? "Local" : "Telegram",
            ChannelId = isLocalFile ? "" : ExtractChannelIdFromUrl(item.Url),
            FileId = isLocalFile ? "" : ExtractFileIdFromUrl(item.Url),
            FileSize = 0,
            Duration = duration,
            IsLocal = isLocalFile,
            QueuePosition = index,
            ContainedInPlaylists = containedIn.Count > 0 ? containedIn : null
        };

        showTrackInfo = true;
        await InvokeAsync(StateHasChanged);
    }

    private void CloseTrackInfo()
    {
        showTrackInfo = false;
        trackInfoData = null;
        StateHasChanged();
    }

    private string FormatFileSize(long bytes)
    {
        if (bytes <= 0) return "Unknown";
        string[] sizes = { "B", "KB", "MB", "GB" };
        int order = 0;
        double size = bytes;
        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size /= 1024;
        }
        return $"{size:0.##} {sizes[order]}";
    }

    private string ExtractFileIdFromUrl(string url)
    {
        try
        {
            if (url.Contains("GetFile") && url.Contains("docId="))
            {
                var uri = new Uri(url, UriKind.RelativeOrAbsolute);
                if (!uri.IsAbsoluteUri)
                    uri = new Uri("http://localhost" + (url.StartsWith("/") ? url : "/" + url));
                var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
                return query["docId"] ?? "";
            }

            var parts = url.Split('/');
            var getFileStreamIndex = Array.IndexOf(parts, "GetFileStream");
            if (getFileStreamIndex >= 0 && getFileStreamIndex + 2 < parts.Length)
            {
                return parts[getFileStreamIndex + 2];
            }
        }
        catch { }
        return "";
    }

    private string ExtractChannelIdFromUrl(string url)
    {
        try
        {
            if (url.Contains("GetFile") && url.Contains("idChannel="))
            {
                var uri = new Uri(url, UriKind.RelativeOrAbsolute);
                if (!uri.IsAbsoluteUri)
                    uri = new Uri("http://localhost" + (url.StartsWith("/") ? url : "/" + url));
                var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
                return query["idChannel"] ?? "";
            }

            var parts = url.Split('/');
            var getFileStreamIndex = Array.IndexOf(parts, "GetFileStream");
            if (getFileStreamIndex >= 0 && getFileStreamIndex + 1 < parts.Length)
            {
                return parts[getFileStreamIndex + 1];
            }
        }
        catch { }
        return "";
    }

    private string ExtractFileTypeFromUrl(string url)
    {
        try
        {
            var urlWithoutQuery = url.Split('?')[0];
            var lastPart = urlWithoutQuery.Split('/').LastOrDefault() ?? "";
            var ext = System.IO.Path.GetExtension(lastPart);
            return string.IsNullOrEmpty(ext) ? ".mp3" : ext;
        }
        catch { return ".mp3"; }
    }

    public async Task ClearPlaylist()
    {
        playlist.Clear();
        currentTrackIndex = -1;
        currentPlaylistId = null;
        currentPlaylistName = null;
        await InvokeAsync(StateHasChanged);
    }

    public async Task PlayTrack(int index)
    {
        if (index >= 0 && index < playlist.Count)
        {
            currentTrackIndex = index;
            var track = playlist[index];
            audioUrl = track.Url;
            audioType = track.Type;
            audioTitle = track.Title;
            progressPercent = 0;
            bufferPercent = 0;
            currentTimeDisplay = "0:00";
            artworkUrl = null;

            bool isTelegramFile = audioUrl.Contains("/api/file/") || audioUrl.Contains("GetFileStream");
            isInitialLoading = isTelegramFile;
            isBuffering = false;
            loadingStatus = isTelegramFile ? "Loading from Telegram..." : "";

            await JSRuntime.InvokeVoidAsync("playAudioPlayer", audioUrl, audioType);
            StartProgressTimer(); // Ensure timer is running when playing a track
            await InvokeAsync(StateHasChanged);
            _ = ExtractArtworkAndUpdateMediaSession(audioUrl);
        }
    }

    private async Task ExtractArtworkAndUpdateMediaSession(string url)
    {
        try
        {
            await ExtractArtwork(url);
            await InitializeMediaSession();
            await UpdateMediaSessionPlaybackState("playing");
        }
        catch { }
    }

    private async Task PlayPrevious()
    {
        if (currentTrackIndex > 0)
        {
            await PlayTrack(currentTrackIndex - 1);
        }
        else if (repeatMode == RepeatMode.All && playlist.Count > 0)
        {
            await PlayTrack(playlist.Count - 1);
        }
    }

    private async Task PlayNext()
    {
        if (currentTrackIndex < playlist.Count - 1)
        {
            await PlayTrack(currentTrackIndex + 1);
        }
        else if (repeatMode == RepeatMode.All && playlist.Count > 0)
        {
            await PlayTrack(0);
        }
    }

    private void RemoveFromPlaylist(int index)
    {
        if (index >= 0 && index < playlist.Count)
        {
            playlist.RemoveAt(index);

            if (index < currentTrackIndex)
            {
                currentTrackIndex--;
            }
            else if (index == currentTrackIndex)
            {
                currentTrackIndex = -1;
            }
            StateHasChanged();
        }
    }

    public async Task AddToPlaylist(string url, string type = "audio/mpeg", string title = "")
    {
        try
        {
            var item = new PlaylistItem
            {
                Url = url,
                Type = string.IsNullOrEmpty(type) ? "audio/mpeg" : type,
                Title = !string.IsNullOrEmpty(title) ? title : ExtractFileName(url)
            };

            if (!playlist.Any(p => p.Url == url))
            {
                playlist.Add(item);
                await InvokeAsync(StateHasChanged);
            }
        }
        catch { }
    }

    public async Task AddToPlaylistAndPlay(string url, string type = "audio/mpeg", string title = "")
    {
        try
        {
            var existingIndex = playlist.FindIndex(p => p.Url == url);

            if (existingIndex >= 0)
            {
                await PlayTrack(existingIndex);
            }
            else
            {
                await AddToPlaylist(url, type, title);
                await PlayTrack(playlist.Count - 1);
            }
        }
        catch { }
    }

    public async Task AddMultipleToPlaylist(List<PlaylistItem> items)
    {
        try
        {
            foreach (var item in items)
            {
                if (!playlist.Any(p => p.Url == item.Url))
                {
                    playlist.Add(new PlaylistItem
                    {
                        Url = item.Url,
                        Type = string.IsNullOrEmpty(item.Type) ? "audio/mpeg" : item.Type,
                        Title = !string.IsNullOrEmpty(item.Title) ? item.Title : ExtractFileName(item.Url)
                    });
                }
            }
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    public async Task AddMultipleToPlaylist(IEnumerable<(string url, string type, string title)> items)
    {
        try
        {
            foreach (var (url, type, title) in items)
            {
                if (!playlist.Any(p => p.Url == url))
                {
                    playlist.Add(new PlaylistItem
                    {
                        Url = url,
                        Type = string.IsNullOrEmpty(type) ? "audio/mpeg" : type,
                        Title = !string.IsNullOrEmpty(title) ? title : ExtractFileName(url)
                    });
                }
            }
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    public async Task SetPlaylistName(string? name, string? id = null)
    {
        currentPlaylistName = name;
        currentPlaylistId = id;
        await InvokeAsync(StateHasChanged);
    }

    // Drag and drop handlers
    private void OnDragStart(int index)
    {
        draggedIndex = index;
        StateHasChanged();
    }

    private void OnDragOver(int index)
    {
        if (draggedIndex.HasValue && draggedIndex.Value != index)
        {
            dragOverIndex = index;
            StateHasChanged();
        }
    }

    private void OnDragLeave()
    {
        dragOverIndex = null;
        StateHasChanged();
    }

    private void OnDrop(int targetIndex)
    {
        if (draggedIndex.HasValue && draggedIndex.Value != targetIndex)
        {
            var sourceIndex = draggedIndex.Value;
            var item = playlist[sourceIndex];

            playlist.RemoveAt(sourceIndex);

            var adjustedTargetIndex = sourceIndex < targetIndex ? targetIndex - 1 : targetIndex;

            playlist.Insert(adjustedTargetIndex, item);

            if (currentTrackIndex == sourceIndex)
            {
                currentTrackIndex = adjustedTargetIndex;
            }
            else if (sourceIndex < currentTrackIndex && adjustedTargetIndex >= currentTrackIndex)
            {
                currentTrackIndex--;
            }
            else if (sourceIndex > currentTrackIndex && adjustedTargetIndex <= currentTrackIndex)
            {
                currentTrackIndex++;
            }
        }

        draggedIndex = null;
        dragOverIndex = null;
        StateHasChanged();
    }

    private void OnDragEnd()
    {
        draggedIndex = null;
        dragOverIndex = null;
        StateHasChanged();
    }

    private string ExtractFileName(string url)
    {
        if (string.IsNullOrEmpty(url)) return "";
        try
        {
            var uri = new Uri(url);
            var path = uri.LocalPath;
            return System.IO.Path.GetFileName(path);
        }
        catch
        {
            return "";
        }
    }

    // Artwork Extraction
    private async Task ExtractArtwork(string url)
    {
        if (string.IsNullOrEmpty(url)) return;

        try
        {
            isLoadingArtwork = true;
            var extractedArtwork = await JSRuntime.InvokeAsync<string?>("extractAndNotifyArtwork", url);
            artworkUrl = extractedArtwork;
            isLoadingArtwork = false;
            await InvokeAsync(StateHasChanged);
        }
        catch
        {
            artworkUrl = null;
            isLoadingArtwork = false;
        }
    }

    // Media Session API Integration
    private async Task InitializeMediaSession()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("initMediaSession", audioTitle, "TelegramFileManager", currentPlaylistName ?? "Playlist", artworkUrl);
        }
        catch { }
    }

    private async Task UpdateMediaSessionPlaybackState(string state)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("updateMediaSessionPlaybackState", state);
        }
        catch { }
    }

    private async Task UpdateMediaSessionPosition(double duration, double position)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("updateMediaSessionPositionState", duration, position, 1.0);
        }
        catch { }
    }

    // Media Session action handlers
    public async Task ResumeFromMediaSession()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("resumeAudioPlayer");
            isPlaying = true;
            await UpdateMediaSessionPlaybackState("playing");
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    public async Task PauseFromMediaSession()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("pauseAudioPlayer");
            isPlaying = false;
            await UpdateMediaSessionPlaybackState("paused");
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    public async Task PlayPreviousFromMediaSession()
    {
        try
        {
            await PlayPrevious();
        }
        catch { }
    }

    public async Task PlayNextFromMediaSession()
    {
        try
        {
            await PlayNext();
        }
        catch { }
    }

    public async Task StopFromMediaSession()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("stopAudioPlayer");
            isPlaying = false;
            progressPercent = 0;
            currentTimeDisplay = "0:00";
            await UpdateMediaSessionPlaybackState("none");
            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    public async Task SeekRelativeFromMediaSession(double offsetSeconds)
    {
        try
        {
            var audioInfo = await JSRuntime.InvokeAsync<AudioInfo>("getAudioInfo");
            if (audioInfo != null && audioInfo.Duration > 0)
            {
                var newTime = Math.Max(0, Math.Min(audioInfo.Duration, audioInfo.CurrentTime + offsetSeconds));
                var percent = (newTime / audioInfo.Duration) * 100;
                await JSRuntime.InvokeVoidAsync("seekAudioPlayer", percent);
            }
        }
        catch { }
    }

    public async Task SeekToFromMediaSession(double positionSeconds)
    {
        try
        {
            var audioInfo = await JSRuntime.InvokeAsync<AudioInfo>("getAudioInfo");
            if (audioInfo != null && audioInfo.Duration > 0)
            {
                var percent = (positionSeconds / audioInfo.Duration) * 100;
                await JSRuntime.InvokeVoidAsync("seekAudioPlayer", percent);
            }
        }
        catch { }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Register DotNet reference for JS calls
            try
            {
                _dotNetRef = DotNetObjectReference.Create(this);
                await JSRuntime.InvokeVoidAsync("setAudioPlayerRef", _dotNetRef);
            }
            catch
            {
                // Function may not be available yet (browser cache), ignore - fallback will be used
            }

            await LoadVisualizerPreference();
            await InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task ShowModalFromJs(string url, string type, string title)
    {
        await ShowModal(url, type ?? "audio/mpeg", title ?? "");
    }

    [JSInvokable]
    public async Task ShowCurrentModalFromJs()
    {
        await ShowCurrentModal();
    }

    public void Dispose()
    {
        _disposed = true;
        StopProgressTimer();
        StopRealVisualizer();
        visualizerCts?.Dispose();
        _dotNetRef?.Dispose();
    }
}
